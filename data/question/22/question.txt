{"content":"<p>Phuongne, Th3 07, 2021</p><hr /><p>&gt; Bài trước: <a href=\"https://viblo.asia/p/unity-basic-25-gioi-thieu-unity-editor-m2vJPeKxLeK\">C2. Giới thiệu Unity Editor</a></p><p>Ở các bài trước, chúng ta đã biết về concept gameObject và component, khi làm một game, các component mà Unity hỗ trợ sẵn như <strong>Transform</strong>, <strong>CanvasGroup</strong>, <strong>Animator</strong>, <strong>Rigidbody</strong>,… là không đủ, chúng chỉ là cái base giúp chúng ta thuận tiện hơn khi tạo game.</p><p>&gt; <em>“Viết script để làm gì?”</em></p><p>Để làm được một game hoàn chỉnh, chúng ta cần phải tạo ra các custom components riêng để gameObject hoạt động như ý muốn.</p><p>Hiện nay có rất nhiều hệ thống visual scripting như Bolt, PlayMaker,… giúp bạn có thể tạo game mà không cần code: <a href=\"https://unity.com/how-to/make-games-without-programming\">Make games without programming</a>.</p><p>Và để tạo component, chúng ta sẽ viết C# scripts, với các class được kế thừa từ MonoBehaviour.</p><p>Lưu ý rằng các file scripts của chúng ta không nhất thiết phải là component, không cần phải là class kế thừa từ MonoBehaviour.</p><h2 id=\"ccthnhphnhnhhc\">Các thành phần hình học</h2><p>Trước khi viết scripts, mình sẽ giúp các bạn về các kiến thức nền tảng, các định nghĩa cần biết:</p><h3 id=\"vector3\">Vector3</h3><p>Chắc các bạn đều đã được học về vector trong hình học không gian ở cấp 3 (hoặc cấp 2), tương tự Unity cũng vậy. Chúng ta sẽ sử dụng concept Vector3 gồm (x, y, z) để định nghĩa một vector trong không gian game.</p><p><img src=\"https://images.viblo.asia/2af32e6a-ccf2-4d80-812f-53adf3ee9232.png\" alt=\"image.png\" />Để tạo một Vector3, sử dụng toán tử new và 3 tham số x, y, z:</p><pre><code class=\"cs language-cs\">Vector3 u = new Vector3 (1 , 2.0f , -3);<br/></code></pre><p>Chúng ta cũng có một số Vector được hỗ trợ sẵn:</p><pre><code class=\"cs language-cs\">Vector3 a = Vector3.left; // (-1, 0, 0)<br/>Vector3 b = Vector3.up; // (0, 1, 0)<br/>Vector3 c = Vector3.forward; // (0, 0, 1)<br/>Vector3 d = Vector3.zero; // (0, 0, 0)<br/></code></pre><p>Trong Unity thì 3 cột x, y và z được định nghĩa như sau: x là cột nằm ngang có chiều từ trái sang phải, y là cột dọc có chiều từ dưới lên và cuối cùng là z có chiều từ bạn tới màn hình máy tính.</p><h3 id=\"ray\">Ray</h3><p>Ray đơn giản nó là một tia (đường) được định nghĩa bởi 1 điểm gốc gọi là origin và một vector hướng. Bạn có thể tưởng tượng như một tia laser bắn ra từ khẩu súng vậy, nòng của súng là origin và vector hướng là hướng súng đang “chĩa” đến trong không gian 3D.</p><p><img src=\"https://images.viblo.asia/1ec500e9-e316-47c4-aa7f-8d089140b5b5.png\" alt=\"image.png\" />&lt;div align=\"center\"&gt;Ray&lt;/div&gt;</p><p>Bạn có thể khai báo một Ray bằng cách đưa 2 tham số là origin và direction như sau:</p><pre><code class=\"cs language-cs\">// Ray bắn từ vị trí (0, 0, 0), có hướng là (1, 0, 0) \"-&amp;gt;\"<br/>Ray ray = new Ray ( Vector3.zero , Vector3.right );<br/></code></pre><p>Chúng ta sẽ thảo luận ứng dụng của ray khi tới phần ray-casting nhé.</p><h3 id=\"quaternion\">Quaternion</h3><p>Quaternion là cấu trúc dùng để biểu diễn hướng xoay của vật trong không gian 3D, tuy nhiên đây không phải là cách duy nhất cung cấp bởi Unity.</p><p>Chắc hẳn bạn đã quen với góc xoay: xoay 30 độ quanh trục x (30, 0, 0), xoay 30 độ quanh trục x và 90 độ theo trục y (30, 90, 0). Góc xoay này được biểu diễn bằng cấu trúc gọi là góc euler hay eulerAngles.</p><p>Có lẽ góc eulerAngles sẽ quen thuộc với chúng ta hơn là Quaternion, đa số trường hợp khai báo hay sử dụng góc xoay, mình cũng sẽ sử dụng eulerAngles.</p><p>Vì vậy thay vì khai báo thẳng giá trị Quaternion, mình sẽ chuyển từ góc euler sang góc quaternion:</p><pre><code class=\"cs language-cs\">Quaternion q1 = Quaternion.Euler (0 , 30 , 0) ;<br/>// xoay 30 độ quanh trục y<br/>Quaternion q2 = Quaternion.AngleAxis (30 , Vector3.up );<br/></code></pre><p>2 kiểu khai báo trên đều cho ra 1 Quaternion giống nhau nhé.</p><h3 id=\"transform\">Transform</h3><p>Mình đã nhắc tới component Transform rất nhiều ở các bài trước, bởi nó là component được “gắn chặt” vào bất kỳ gameObject nào trên Scene.</p><p><img src=\"https://images.viblo.asia/eaf5762f-35a6-464f-a4af-e3b38f932ade.png\" alt=\"image.png\" />&lt;div align=\"center\"&gt;Transform Component&lt;/div&gt;</p><p>Component này sẽ lưu trữ 3 thứ cơ bản sau: vị trí (position), góc xoay (rotation) và tỉ lệ (scale) của một gameObject, thông qua component này bạn có thể truy cập position cũng như rotation bằng cách: transform.rotation, transform.position.</p><p>Transform cũng cung cấp các hàm giúp bạn thay đổi position và rotation dễ dàng hơn như Translate(), Rotate():</p><pre><code class=\"cs language-cs\">// di chuyển vị trí theo trục y 1 đơn vị<br/>transform.Translate (new Vector3 (0, 1 ,0));<br/>// xoay quanh trục y 30 độ<br/>transform.Rotate (0, 30 ,0);<br/></code></pre><p>&gt; <em>“Các hàm này di chuyển và xoay theo global space hay local space?”</em></p><p>Nếu các bạn đã biết về local space và global space trong Unity thì không cần lo về vấn đề này, bạn có thể cung cấp thêm một tham số là enum Space { Self, World } để chỉ rõ là space nào.</p><p>Nhắc lại một chút, chúng ta đã biết về mối quan hệ phân cấp ở bài trước trên tab Hierachy, nếu bạn di chuyển gameObject parent, các children cũng sẽ di chuyển theo và giữ một vị trí tương đối với parent của nó.</p><p>Để tham chiếu tới parent, bạn có thể sử dụng component Transform: transform.parent, hoặc thay đổi parent: transform.SetParent(otherParent). Đồng thời từ parent bạn cũng có thể loop qua toàn bộ children của nó.</p><h2 id=\"monobehaviour\">MonoBehaviour</h2><p>Như mình đã nói ở đầu bài viết, để tạo một component, chúng ta cần viết một class kế thừa MonoBehaviour</p><p>&gt; <em>“Tại sao kế thừa MonoBehaviour lại trở thành Component?”</em></p><p>Đây là framework của Unity, chúng ta chỉ cần làm theo thôi, nếu vẫn thắc mắc thì bạn có thể xem cây kế thừa của nó: MonoBehaviour : Behaviour : Component.</p><p>Để tạo một scripts, bạn có thể tạo trực tiếp trong gameObject trên Inspector hoặc chuột phải vào tab Project, chọn Create và C# Script.</p><h3 id=\"cutrccamonobehaviour\">Cấu trúc của MonoBehaviour</h3><p>Khi khởi tạo một scripts, giả sử như class tên Temp chẳng hạn, Unity sẽ tạo sẵn template cho các bạn để hướng dẫn cách sử dụng:</p><pre><code class=\"cs language-cs\">using System.Collections;<br/>using System.Collections.Generic;<br/>using UnityEngine;<br/>public class Temp : MonoBehaviour<br/>{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Start is called before the first frame update<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void Start() {}<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// Update is called once per frame<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void Update() {}<br/>}<br/></code></pre><p>Nào hãy cùng quan sát một chút đoạn code trên.</p><p>Đầu tiên chúng ta có các lệnh <code>using</code> để sử dụng các chức năng trong namespace đó như System.Collection để sử dụng các cấu trúc dữ liệu như ArrayList, Stack, Queue, HashTable,… nhưng chúng là của C#.</p><p>Chúng ta chỉ quan tâm đến <code>using UnityEngine;</code>, nhờ namespace này mà chúng ta có thể sử dụng các concepts mà mình đã hướng dẫn ở trên kể cả <strong>MonoBehaviour</strong>.</p><p>Như vậy là bạn đã tạo được component Temp, chúng ta có thể kéo thả nó vào gameObject bất kỳ hoặc chọn Add Component ở tab Inspector và chọn Temp.</p><h3 id=\"vitgtrongscripts\">Viết gì trong Scripts?</h3><p>Đa số các class script trong Unity đều liên quan đến 3 thứ: <strong>khởi tạo state</strong> (các giá trị của component), <strong>chạy update</strong> để thực hiện logic theo vòng đời của game, <strong>quản lý state</strong>.</p><p>Template trên đã cung cấp cho bạn 2 hàm rỗng là <code>Start()</code> và <code>Update()</code> để bạn viết vào, tất nhiên bạn cũng có thể xóa chúng đi. Giả sử component của bạn không cần khởi tạo, bạn có thể xóa hàm Start() đi.</p><ul><li><code>Start()</code>: khi chương trình bắt đầu, hàm này sẽ được gọi trước Update() để <strong>khởi tạo</strong> các giá trị của component (class).</li><li><code>Update()</code>: chạy <strong>liên tục</strong> vào mỗi frame, giả sử game của bạn là 60fps, như vậy hàm này sẽ thực thi 60 lần trong 1s, nếu bạn chưa biết về cách game hoạt động có thể đọc qua một chút về fps (frame per second) nhé.</li></ul><h3 id=\"awakevstart\">Awake và Start</h3><p>Mình đã có một bài viết nói về <a href=\"https://viblo.asia/p/awake-start-va-mot-so-ham-co-ban-trong-monobehaviour-qPoL77nNLvk\">Awake, Start và một số hàm cơ bản trong MonoBehaviour</a>.</p><p>Có 2 functions điển hình trong Unity được sử dụng với mục đích khởi tạo đó là <code>Start()</code> và <code>Awake()</code>, cả 2 hàm này đều chỉ được gọi một lần tương ứng với bất kỳ gameObject nào.</p><p>Awake sẽ được gọi đầu tiên, và thực thi ngay khi gameObjects được khởi tạo bởi Unity, trừ khi gameObject đó bị deactive.</p><p>&gt; <em>“gameObject bị deactive là gì?”</em></p><p>Mỗi gameObject của chúng ta đều có trạng thái <strong>active</strong> hoặc <strong>deactive</strong>, được định nghĩa bằng thuộc tính <code>bool gameObject.activeSelf</code>.</p><p>&gt; <em>“Enable/ disable và active/ deactive khác gì nhau?”</em></p><p>Theo mình biết, <strong>enable/ disable</strong> chỉ sử dụng cho component, nó chỉ dừng component trong gameObject, còn <strong>active/ deactive</strong> sẽ có tác dụng với gameObject (hoặc toàn bộ components)</p><p>Bạn có thể <strong>disable</strong> từng component riêng lẻ như Rigidbody, Collider,… như vậy các logic trong các components này hầu hết sẽ không được chạy. Ví dụ bạn có component SpriteRenderer dùng để vẽ vật 2D, nếu bạn disable nó đi thì component này sẽ không render ảnh cho bạn.</p><p>Khi <strong>deactive</strong> một gameObject, <strong>toàn bộ</strong> các components sẽ vào trạng thái inactive và dừng chạy logic như bị disable vậy. Tuy nhiên khi components vào trạng thái deactive không có nghĩa là nó disabled nhé.</p><p>&gt; <em>“Vậy thì liên quan gì tới Start và Awake?”</em></p><ul><li>Khi bạn deactive một gameObject, cà Awake() và Start() sẽ <strong>không</strong> được gọi.</li><li>Khi bạn active một gameObject, và component bị disable, Awake() được gọi nhưng Start() thì <strong>không</strong>.</li><li>Khi bạn active một gameObject và component được enable, Awake() gọi sau đó đến Start().</li></ul><h3 id=\"update\">Update</h3><p>Như mình đã đề cập, hàm <code>Update()</code> sẽ được gọi trong mỗi frame, 1 giây có thể có 50, 60,… frames. Số lượng frames trong một giây là không có định, vì vậy số lần gọi của nó trong 1 giây cũng không cố định.</p><p>Update() được gọi <strong>sau</strong> Awake() và Start(), khi các bước khởi tạo đã hoàn tất.</p><p>Mặc dù không ổn định nhưng bạn có thể cài đặt fps mục tiêu mà bạn hướng tới bằng: <code>Application.targetFrameRate = 60;</code> chẳng hạn. Tuy nhiên có thể máy với cpu (/gpu) ổn định, tốc độ tốt sẽ chạy 60 fps, người có cpu yếu có thể sẽ chạy 30 fps.</p><p>&gt; “Giả sử mình tăng tốc độ nhân vật trong Update(), người có cpu ổn định thì tốc độ nhân vật sẽ <strong>tăng</strong> 60 lần trong 1s, cpu yếu sẽ là 30 lần trong 1s, tốc độ nhân vật bị ảnh hưởng bởi fps không?”</p><p>Đúng vậy, người có 60 fps sẽ chạy nhanh hơn 30 fps trong 1s nếu:</p><pre><code class=\"cs language-cs\">private void Update()<br/>{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// di chuyển sang phải 1 đơn vị mỗi lần Update()<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transform.Translate(new Vector3(1, 0, 0));<br/>}<br/></code></pre><p>Để fix trường hợp này, chúng ta cần một điều kiện sao cho trong trường hợp 60 fps, tốc độ tăng trong Update() sẽ chậm hơn so với tốc độ tăng trong Update() của 30 fps.</p><p>Như vậy để chúng bằng nhau trong 1s thì phải: <code>60 * x * new Vector3(1, 0, 0) = 30 * x * new Vector3(1, 0, 0);</code></p><p>May mắn là Unity cung cấp cho chúng ta số <strong>x</strong>, được gọi là <code>Time.deltaTime</code>, biếu diễn thời gian của 1 frame.</p><p>&gt; “Vậy thì sao?”</p><p>Thời gian của 1 frame đối với:</p><ul><li>60 FPS: 1s / 60 = 0.00166667 (s)</li><li>30FPS: 1s / 30 = 0.03333333 (s)</li></ul><p>Nếu bạn thay x vào, công thức của chúng ta đã đúng: <code>60 * 1/60 * Vector3 == 30 * 1/30 * Vector3</code>.</p><p>Và đó là lý do tại sao phải nhân Time.deltaTime khi di chuyển:</p><pre><code class=\"cs language-cs\">private void Update()<br/>{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transform.Translate(new Vector3(1, 0, 0) * Time.deltaTime);<br/>}<br/></code></pre><h3 id=\"updatevfixedupdate\">Update và FixedUpdate</h3><p>Unity còn cung cấp cho chúng ta một hàm tương tự như Update, tuy nhiên có thêm tiền tố “<strong>Fixed</strong>“, nếu bạn đã đọc Update ở trên thì chúng ta biết rằng Update “không ổn định” (do yếu tố fps, giật lag).</p><p>Nhưng <code>FixedUpdate()</code> sẽ cực kỳ ổn định và được gọi hầu như đúng số lượng frame trong 1s, default của nó là 50 fps với <code>Time.fixedDeltaTime</code> là 0.02f, bạn có thể sửa trong settings.</p><p>&gt; <em>“Vậy tại sao lại dùng FixedUpdate?”</em></p><p>Update của chúng ta không thể áp dụng được cho các yếu tố vật lý nếu FPS không ổn định, ví dụ như vận tốc của một vật bị rơi chẳng hạn, bạn sẽ muốn vận tốc thay đổi theo gia tốc (g) của vật trong mỗi khoảng thời gian đều đặn.</p><p>Vì vậy, các xử lý code về vật lý hãy đặt chúng trong FixedUpdate nhằm kết hợp với các hàm vật lý khác của Unity như <strong>OnCollisionXXX</strong>, <strong>OnTriggerXXX</strong>,… bạn có thể đọc thêm <a href=\"https://viblo.asia/p/awake-start-va-mot-so-ham-co-ban-trong-monobehaviour-qPoL77nNLvk\">Execution orders</a> để biết thêm các thông tin khác.</p><p>&gt; <em>“Còn loại Update nào không?”</em></p><h3 id=\"lateupdate\">LateUpdate</h3><p>LateUpdate được gọi sau khi <strong>tất cả</strong> các Update() trong frame đó đã được gọi xong, và trước khi màn hình được redrawing.</p><p>Có một use-case duy nhất mà mình sử dụng LateUpdate() đó là di chuyển của Camera, khi bạn muốn camera di chuyển theo nhân vật chẳng hạn, bạn sẽ không biết Update() của camera hay Update() của Player chạy trước, trong khi bạn muốn camera phải bắt kịp vị trí của Player.</p><p>Vì vậy đặt xử lý follow player ở LateUpdate(), camera có thể follow Player sau khi Player đã di chuyển xong xuôi (trong Update).</p><h2 id=\"claims\">Claims</h2><p>Bài viết được đăng vào 2021, chỉ có giá trị tham khảo các bạn nhé ;)</p><h2 id=\"tmli\">Túm lại</h2><p>Nếu bạn thấy bối rối thì đừng lo, hãy cứ nghĩ đặt khởi tạo code ở Start() và chỉnh sửa thông số ở Update(), làm càng nhiều thì bạn sẽ biết nên đặt code ở đâu và sử dụng hàm nào.</p><p>Để biết thêm nhiều hàm, hãy xem bảng <a href=\"https://viblo.asia/p/awake-start-va-mot-so-ham-co-ban-trong-monobehaviour-qPoL77nNLvk\">thứ tự thực hiện các hàm trong Unity</a>.</p><p>&gt; Bài tiếp theo: <a href=\"https://viblo.asia/p/unity-basic-45-lam-quen-voi-scripts-reference-public-collision-rigidbody-AZoJjKvgLY7\">C4. Làm quen với Scripts (Reference, public, Collision, Rigidbody, Kinematic, Static,…)</a></p>","title":"Unity Basic (3/5): Làm quen với Scripts (Geometry, Start, Awake, Update,…)","tags":["Unity3d"],"created_at":1690705084000,"updated_at":1692529213000,"comments":[]}