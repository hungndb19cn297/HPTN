{"content":"<p>Đây là bài viết nằm trong Series <strong>NestJS thực chiến</strong>, các bạn có thể xem toàn bộ bài viết ở link: https://viblo.asia/s/nestjs-thuc-chien-MkNLr3kaVgA</p><hr /><h1 id=\"tvn\">Đặt vấn đề</h1><p><img src=\"https://images.viblo.asia/6b9fa443-b636-43c7-ac14-6c6bc4214a52.png\" alt=\"\" /></p><p><strong>Error Handling</strong> là một chủ đề không mới và luôn luôn hiện diện trong bất kì dự án nào mà chúng ta tham gia. Vì thế việc triển khai như thế nào để hiệu quả và bảo mật là điều chúng ta cần quan tâm. Thông thường chúng ta cần đáp ứng các yêu cầu sau:</p><ul><li><strong>(1)</strong>. <strong>Recognizable</strong>: Phải giúp người sử dụng API <strong>phân biệt được lỗi</strong> giữa từ <strong>client</strong> và lỗi từ <strong>server</strong>: <ul><li>Lỗi từ client sẽ là các lỗi 4xx (unauthenticate, validation error,…): khi đó họ phải chỉnh sửa lại thông tin request.</li><li>Lỗi từ server là các lỗi 5xx(bad gateway, service unavailable): với các lỗi này người dùng có thể thử gọi lại mà không cần thay đổi gì. </li></ul></li><li><strong>(2)</strong>. <strong>Give Context</strong>: Lỗi trả về từ API phải bao gồm context để có thể dễ dàng tìm ra nguyên nhân nơi nó phát sinh để giải quyết. </li><li><strong>(3)</strong>. <strong>Human Readability</strong>:  <strong>(2)</strong> là giúp cho BE fix error, còn phía FE chỉ cần một vài thông tin để kiểm soát lỗi nên chúng ta cần làm sao để khi nhìn vào, họ có thể biết được cơ bản lỗi đó là gì.</li><li><strong>(4)</strong>. <strong>High security</strong>: Khi triển khai môi trường production, các thông tin lỗi trả về phải đảm bảo các vấn đề bảo mật. Thường chỉ là dạng dictionary, không được chứa bất cứ thông tin gì về context.</li></ul><h1 id=\"thngtinpackage\">Thông tin package</h1><p>Các bạn có thể tải về toàn bộ source code của phần này <a href=\"https://github.com/nntwelve/Boilerplate-NestJS/tree/part-7-error-handling-and-serialize-response\">tại đây</a>.</p><h1 id=\"trinkhai\">Triển khai</h1><p>Để bắt đầu chúng ta sẽ viết một <strong>GlobalExceptionFilter</strong> để override lại default của NestJS, ở đây chúng ta sẽ chuẩn hóa lại các thông tin response để đảm bảo các yêu cầu ở phần trên.</p><pre><code class=\"typescript:src/exception-filters/global-exception.filter.ts language-typescript:src/exception-filters/global-exception.filter.ts\">import {<br/>    ArgumentsHost,<br/>    Catch,<br/>    ExceptionFilter,<br/>    HttpException,<br/>} from '@nestjs/common';<br/>import { ConfigService } from '@nestjs/config';<br/>import { Response } from 'express';<br/>@Catch()<br/>export class GlobalExceptionFilter implements ExceptionFilter {<br/>    constructor(private readonly config_service: ConfigService) {}<br/>    catch(exception: any, host: ArgumentsHost) {<br/>        const ctx = host.switchToHttp();<br/>        const response = ctx.getResponse&amp;lt;Response&amp;gt;();<br/>        const status =<br/>            exception instanceof HttpException ? exception.getStatus() : 500;<br/>        const message =<br/>            exception instanceof HttpException<br/>                ? exception.message<br/>                : 'Internal server error';<br/>        response.status(status).json({<br/>            statusCode: status,<br/>            message,<br/>            error:<br/>                this.config_service.get('NODE_ENV') !== 'production'<br/>                    ? {<br/>                            response: exception.response,<br/>                            stack: exception.stack,<br/>                      }<br/>                    : null,<br/>        });<br/>    }<br/>}<br/></code></pre><p>Giải thích:</p><ul><li>Để đáp ứng yêu cầu <strong>(1)</strong> chúng ta sẽ kiểm tra <code>exception</code> catch được có phải là <code>HttpException</code> không. Nếu đúng thì là thường là lỗi từ client, còn lại là của server hoặc các third-party package.</li><li><code>response.status(status)...</code> chỗ này có nhiều cách triển khai tùy vào team dev, có team sẽ luôn trả về 200 và chỉ trả về 500 khi lỗi server, có team thì luôn trả về 200 và lỗi thì trả về 400 và họ đều có lý do riêng của mình. Phần này là tùy thuộc vào mỗi người, còn mình không làm cách đó mà sẽ trả đúng status để tránh khi có lỗi phía FE phải check 2 lần mới biết được message lỗi là gì. </li><li><code>...json({ statusCode: status, message, ...})</code> với các lỗi từ phía client chúng ta sẽ hiển thị ra message, ở phía dưới chúng ta sẽ nói rõ hơn nội dung của message. Còn về phần statusCode thì mình chỉ dùng cho trường hợp FE cần, các bạn có thể bỏ cũng được.</li><li>Các thông tin về stack trace của lỗi hoặc response chi tiết sẽ được ẩn ở môi trường production <strong>(4)</strong>. </li></ul><p>Để sử dụng chúng ta sẽ thêm vào <code>AppModule</code> (do chúng ta có inject <code>ConfigService</code> nên không thể dùng trong file main.ts):</p><pre><code class=\"typescript:src/app.module.ts language-typescript:src/app.module.ts\">import { APP_FILTER } from '@nestjs/core';<br/>import { GlobalExceptionFilter } from './exception-filters/global-exception.filter';<br/>...<br/>@Module({<br/>    ...<br/>    providers: [<br/>        AppService,<br/>        {<br/>            provide: APP_FILTER,<br/>            useClass: GlobalExceptionFilter,<br/>        },<br/>    ],<br/>})<br/>export class AppModule {}<br/></code></pre><p>Chúng ta đã xong với yêu cầu <strong>(1)</strong> và <strong>(4)</strong>, tiếp theo để làm cho error chúng ta trở nên đầy đủ context hơn mình sẽ tạo ra một dictionary chứa danh sách các lỗi bằng message code để làm ví dụ.</p><pre><code class=\"typescript:src/constraints/error-dictionary.constraint.ts language-typescript:src/constraints/error-dictionary.constraint.ts\">export enum ERRORS_DICTIONARY {<br/>    // AUTH<br/>    EMAIL_EXISTED = 'ATH_0091',<br/>    WRONG_CREDENTIALS = 'ATH_0001',<br/>    CONTENT_NOT_MATCH = 'ATH_0002',<br/>    UNAUTHORIZED_EXCEPTION = 'ATH_0011',<br/>    // TOPIC<br/>    TOPIC_NOT_FOUND = 'TOP_0041',<br/>    // USER<br/>    USER_NOT_FOUND = 'USR_0041',<br/>    // CLASS VALIDATOR<br/>    VALIDATION_ERROR = 'CVL_0001',<br/>}<br/></code></pre><p>&gt; Việc quy định error code có định dạng như thế nào tùy thuộc vào các thành viên trong team thống nhất, làm sao khi nhìn vào các bạn có thể biết ngay lỗi đó thuộc về module nào và loại lỗi là gì. Ví dụ ở đây ATH_0091: ATH = Auth, 009 = 409 và 1 dùng để phân biệt giữa các lỗi 409 của module Auth (conflic email, username,…). </p><p>Khi sử dụng chúng ta sẽ kết hợp với các sub-class của <code>HttpException</code> để <code>GlobalExceptionFilter</code> có thể nhận biết đó là <code>instanceof HttpException</code>:</p><pre><code class=\"typescript:src/modules/auth/auth.service.ts language-typescript:src/modules/auth/auth.service.ts\">import { ERRORS_DICTIONARY } from 'src/constraints/error-dictionary.constraint';<br/>...<br/>export class AuthService {<br/>    ...<br/>    async getAuthenticatedUser(email: string, password: string): Promise&amp;lt;User&amp;gt; {<br/>        try {<br/>            ...<br/>        } catch (error) {<br/>            throw new BadRequestException({<br/>                message: ERRORS_DICTIONARY.WRONG_CREDENTIALS,<br/>            });<br/>        }<br/>    }<br/></code></pre><p>Có thể thấy ở phía môi trường dev, codebase chúng ta sử dụng rất tường minh, khi nhìn vào là biết ngay là lỗi gì - có thể chi tiết hơn nữa <code>WRONG_CREDENTIALS</code> thành <code>WRONG_EMAIL_PASS_CREDENTIALS</code> để phân tách giữa các loại của nó. </p><p>Khi đăng nhập với thông tin không hợp lệ kết quả sẽ hiển thị như sau:</p><p><img src=\"https://images.viblo.asia/9f87bb2f-3f80-49cd-9e10-1f7a496a7615.png\" alt=\"image.png\" /></p><p>Đứng ở phía BE khi nhìn vào response, chúng ta đã có thể biết được lỗi đó nằm ở đâu trong code dựa vào stack trace, kết hợp với error code <code>ATH_0001</code> chúng ta biết được đó là lỗi do chưa đăng nhập nên không có quyền truy cập. Như vậy chúng ta tiếp tục thỏa mãn được yêu cầu <strong>(2)</strong>.</p><p>Tuy nhiên ở phương diện FE, khi nhìn vào response trên họ sẽ không biết ngay lỗi là gì mà phải vào xem chú thích để tra dựa vào error code, việc đó rất bất tiện. Để khắc phục chúng ta cần làm gì đó để cho nó có tính <strong>Human Readability</strong> hơn, đây cũng là yêu cầu <strong>(3)</strong>.</p><pre><code class=\"typescript:src/modules/auth/auth.service.ts language-typescript:src/modules/auth/auth.service.ts\">import { ERRORS_DICTIONARY } from 'src/constraints/error-dictionary.constraint';<br/>...<br/>export class AuthService {<br/>    ...<br/>    async getAuthenticatedUser(email: string, password: string): Promise&amp;lt;User&amp;gt; {<br/>        try {<br/>            ...<br/>        } catch (error) {<br/>            throw new BadRequestException({<br/>                message: ERRORS_DICTIONARY.WRONG_CREDENTIALS,<br/>                details: 'Wrong credentials!!',<br/>            });<br/>        }<br/>    }<br/></code></pre><p>Bằng cách thêm vào property <code>details</code> chúng ta có thể diễn giải được nội dung lỗi chi tiết hơn, khi đó FE hoặc bất kì bên nào sử dụng API của chúng ta của có thể nắm bắt được cơ bản của vấn đề. </p><p>Kết quả cuối cùng chúng ta mong đợi như sau:</p><p><img src=\"https://images.viblo.asia/ced3396f-c72d-40d0-8abd-fe8e190f6895.png\" alt=\"\" /></p><p>Nếu ở môi trường production thì sẽ như sau:</p><p><img src=\"https://images.viblo.asia/2f3ac3c1-d564-4a12-992e-87f0855efd5b.png\" alt=\"image.png\" /></p><p>Có thể thấy được, việc chuẩn bị Error Handling cho dự án trước khi bắt tay vào code sẽ giúp ít cho chúng ta cũng như người sử dụng API rất nhiều. Hạn chế tối đa được các tình huống khi những thành viên khác trong team sử dụng API gặp lỗi và phải liên hệ cho chúng ta vì không biết được đó là lỗi gì.</p><h1 id=\"ktlun\">Kết luận</h1><p>Tuy bài viết này khá ngắn gọn nhưng chúng ta đã bao quát được khá nhiều về việc xử lý lỗi trong dự án NestJS và triển khai các giải pháp nhằm đáp ứng các yêu cầu quan trọng như phân biệt lỗi client/server, cung cấp context, đảm bảo đọc được cho người đọc lỗi và bảo mật thông tin. Việc chuẩn bị quy trình xử lý lỗi từ đầu sẽ giúp giảm thiểu các tình huống lỗi và tăng tính ổn định của ứng dụng, đồng thời cung cấp trải nghiệm tốt hơn cho người dùng API.</p><p>Hẹn gặp lại các bạn vào các bài viết tiếp theo. Cảm ơn các bạn đã giành thời gian đọc bài viết. </p><h1 id=\"tiliuthamkho\">Tài liệu tham khảo</h1><ul><li>Fronczak, S. (2023) Web api error handling: How to make debugging easier, Stackify. Available at: https://stackify.com/web-api-error-handling/ (Accessed: 30 July 2023). </li><li>Sandoval, K. (2017) Best practices for API error handling: Nordic apis |, Nordic APIs. Available at: https://nordicapis.com/best-practices-api-error-handling/ (Accessed: 30 July 2023). </li><li>PostgreSQL error codes (2021) PostgreSQL Documentation. Available at: https://www.postgresql.org/docs/9.6/errcodes-appendix.html (Accessed: 30 July 2023). </li><li>Documentation: Nestjs - a progressive node.js framework (no date) NestJS. Available at: https://docs.nestjs.com/exception-filters (Accessed: 30 July 2023).</li></ul>","title":"Setup Boilerplate cho dự án NestJS - Phần 7: Thế nào là một Error Handling hiệu quả","tags":["Error Handling","nestjs","Boilerplate","NodeJS Architecture"],"created_at":1690691676000,"updated_at":1692504485000,"comments":[]}