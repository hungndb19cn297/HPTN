{"content":"<p>Các bạn có thể xem toàn bộ series ở <a href=\"https://viblo.asia/s/toi-uu-database-DVK2jDrnKLj\">đây</a></p><p>Phần này tôi sẽ nói về các điều kiện ngu ảnh hưởng tới các index <a href=\"https://viblo.asia/p/tang-toc-database-index-phan-6-index-ket-hop-vyDZOBRkKwj\">kết hợp</a> </p><p>Phần đầu tiên sẽ về kiểu date và time,  giả sử bạn có một cột lưu date, một cột lưu time. Mà bạn muốn kết hợp chúng để quy thi theo range như sau</p><pre><code class=\"SQL language-SQL\">SELECT ...<br/>  FROM ...<br/> WHERE ADDTIME(date_column, time_column)<br/>     &amp;gt; DATE_ADD(now(), INTERVAL -1 DAY)<br/></code></pre><p>Câu lệnh trên để select những bản ghi có thời gian từ 24 giờ trở lại đây.  Câu truy vấn không thể sử dụng index trên hai trường (DATE<em>COLUMN, TIME</em>COLUMN)  bởi vì không truy vấn trực tiếp trên hai trường đó, mà dựa trên hàm.</p><p>Bạn có thể tránh chúng bằng việc thêm một column nữa có dạng datetime, và select trên column này mà không cần gọi funtion như sau</p><pre><code class=\"SQL language-SQL\">SELECT ...<br/>  FROM ...<br/> WHERE datetime_column<br/>     &amp;gt; DATE_ADD(now(), INTERVAL -1 DAY)<br/></code></pre><p>Nhưng thực tế thêm một cột không phải việc có thể thực hiện ngay  trên môi trường chính thức.</p><p>Một cách khác là sử dụng <a href=\"https://viblo.asia/p/tang-toc-database-index-phan-8-function-tim-kiem-khong-phan-biet-chu-hoa-chu-thuong-upper-va-lower-aWj53zQpl6m\">Function-Base index</a>. Tuy nhiên cũng cần nhớ là cách này không dùng được Mysql bản 5.</p><p>Có một cách khác để truy vấn mà vẫn đùng được index kết hợp trên hai cột này DATE<em>COLUMN, TIME</em>COLUMN, ít nhất là một phần bằng cách sửa câu lệnh như sau</p><pre><code class=\"SQL language-SQL\"> WHERE ADDTIME(date_column, time_column)<br/>     &amp;gt; DATE_ADD(now(), INTERVAL -1 DAY)<br/>   AND date_column<br/>    &amp;gt;= DATE(DATE_ADD(now(), INTERVAL -1 DAY))<br/></code></pre><p>Chúng ta để ý câu lệnh trên, so với lệnh ban đầu chúng ta thêm một điều kiện so sánh với date_column, điều này rõ ràng là thêm điều kiện vào câu truy vấn tại sao lại nhanh hơn? Đáng ra thêm điều kiện thì phải so sánh nhiều hơn chậm hơn mới phải chứ? . Rõ ràng thấy điều kiện thứ hai là dư thừa, tuy nhiên nó có thể sử dụng index. Mặc dù nó không hoàn hảo nhưng về hiệu năng rõ ràng là có tốt hơn. </p><p>&gt; TIP: Có thể sử dụng điều kiện dư thừa trên cột có ý nghĩa nhất trong điều kiện sử dụng range condition kết hợp nhiều điều kiện. Nhắc lại một chút thông thường database truy vấn  sẽ có các điều kiện Equal là bằng và chỉ 1, Range là trên một khoảng, Full là toàn bộ.</p><p>Một cách khác ít dùng hơn là có thể lưu date và time theo kiểu string, nhưng để so sánh được chính xác thì phải lưu đúng theo kiểu sao cho thứ tự theo thời gian và thứ tự theo string sẽ có kết quả giống nhau ví dụ  ISO 8601 (YYYY-MM-DD HH:MM:SS). Như ví dụ dưới đấy sử dụng kiểu TO_CHAR cho Oracle</p><pre><code class=\"SQL language-SQL\">SELECT ...<br/>  FROM ...<br/> WHERE date_string || time_string<br/>     &amp;gt; TO_CHAR(sysdate - 1, 'YYYY-MM-DD HH24:MI:SS')<br/>   AND date_string<br/>    &amp;gt;= TO_CHAR(sysdate - 1, 'YYYY-MM-DD')<br/></code></pre><p>Nói chung cách này cũng không hay, không nên sử dụng vì như bài trước có nói kiểu nào dùng kiểu đó sẽ hay hơn mà tránh gây hiểu lầm.</p><p>Đôi khi chúng ta lại muốn sử dụng Obfuscated Conditions (lần này nó không ngu nên mình để nguyên) để không muốn sử dụng điều kiện đó như một access predicate.</p><p>&gt; Access predicates: là điều kiện bắt đầu hoặc kết thúc việc tìm kiếm theo index. Nó xác định phạm vi index được quét.</p><p>Tại sao lại như vậy? Xem xét câu lệnh sau đây</p><pre><code class=\"SQL language-SQL\">SELECT last_name, first_name, employee_id<br/>  FROM employees<br/> WHERE subsidiary_id = ?<br/>   AND last_name LIKE ?<br/></code></pre><p>Như ở bài trước có nói về việc sử dụng query với <a href=\"https://viblo.asia/p/tang-toc-database-index-phan-10-query-voi-tham-so-3Q75wvL9lWb\">tham số với like </a> có thể mang lại hiệu năng không tốt. Vì khi query theo tham số execution plan được cache lại, nên các lệnh sau sẽ tiếp tục sử dụng phương án của câu lệnh trước mà không quan tâm tới độ phân tán dữ liệu. Ví dụ nếu như câu lệnh đầu tiên like với pattern sau \"abc%\" thì sẽ sử dụng được index trên cột last<em>name. Tuy nhiên câu sau lại like theo điều kiện \"%abc\" thì sẽ không sử dụng được index trên cột last</em>name. Vì vậy với toán tử LIKE mà điều kiện chúng ta mỗi lúc pattern một kiểu thì không nên truyền tham số. Để trình optimize phải đoán xem có dùng index hay không. Nếu câu lệnh like luôn có % ở đầu có thể dùng lệnh sau để optimize không cần đoán và cân nhắc việc dùng index trên last_name nữa.</p><pre><code class=\"SQL language-SQL\">SELECT last_name, first_name, employee_id<br/>  FROM employees<br/> WHERE subsidiary_id = ?<br/>   AND last_name || '' LIKE ?<br/></code></pre><p>Chỉ cần ghép thêm chuỗi  empty vào last<em>name là đủ để câu truy vấn không sử dụng index trên last</em>name nữa. Tuy nhiên việc này cũng cần cân nhắc, chỉ nên dùng khi biết chắc chắn nó thực sự cần thiết. </p><p>Mình có lập group <a href=\"https://www.facebook.com/groups/3277228842495302\">Standard Dev</a> các bạn có thể Join để xây dựng một cộng đồng lập trình viên level quốc tế nhé!</p>","title":"Tăng tốc database index phần 16.2 - Điều kiện ngu (Obfuscated Conditions) với Combining Columns","tags":["Database","index"],"created_at":1691899988000,"updated_at":1691983450000,"comments":[]}