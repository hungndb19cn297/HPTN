{"content":"<p>Ở bài này mình sẽ đi sâu hơn 1 tí về cách thức vận hành của CPU và GPU và thông qua đó chúng ta sẽ trả lời được câu hỏi cuối cùng mà mình đã đề cập ở <a href=\"https://viblo.asia/p/lap-trinh-song-song-bai-3-hello-world-cuda-c-0gdJzxbkVz5\">bài 3</a></p><h1 id=\"ltdivaligncentergtcpuvgpultdivgt\"><strong>&lt;div align=\"center\"&gt;CPU và GPU&lt;/div&gt;</strong></h1><p>&gt; Hồi xưa mình đã từng có câu hỏi ngớ ngẫn là CPU và GPU thì cái nào quan trọng hơn hay là khi mua máy tính chúng ta nên ưu tiên CPU hay là GPU hơn thì câu trả lời sẽ là tùy thuộc vào mục tiêu sử dụng của chúng ta để xác định nên ưu tiên cái nào hơn vì <strong>CPU và GPU được thiết kế với các mục đích khác nhau</strong></p><h2 id=\"approachestoprocessordesign\">Approaches to processor Design</h2><p><img src=\"https://images.viblo.asia/92a9add5-a9e1-4465-89bd-84241265ee9c.png\" alt=\"Screenshot from 2023-07-07 09-14-23.png\" />CPU và GPU được thiết kế với 2 mục tiêu khác nhau nên không thể so sánh với nhau được, vậy thì 2 mục tiêu đó là gì?</p><h3 id=\"cpulatencyorienteddesign\">CPU: Latency-Oriented Design</h3><p>Là phương pháp thiết kế với mục tiêu là làm giảm độ trễ hoặc thời gian phản hồi trong việc <strong>xử lí các task phức tạp nhưng số lượng ít</strong>. Tại sao lại là giảm độ trễ hoặc thời gian phản hồi? Là vì CPU được thiết kế với số lượng cores <strong>rất ít</strong> NHƯNG bù lại mỗi core của CPU <strong>rất là chất lượng, rất là mạnh, rất là xịn</strong> nên ta có thể nói core của CPU đa nhiệm ( ví dụ như: thực thi các tác vụ ứng dụng, quản lí tài nguyên, điều khiển hệ thống, xử lí thông tin,…)</p><p>==&gt; CPU dùng để xử lí các task phức tạp nên vì vậy mục tiêu khi thiết kế CPU là giảm độ trễ hoặc thời gian phản hồi khi xử lí các task đó.</p><p>Như trong hình ta có thể thấy Control Unit và Cache chiếm phần lớn diện tích:</p><ul><li>Control unit lớn: giúp tối ưu trong việc điều khiển các phép logic phức tạp (AND, OR, XOR, ..)</li><li>Cache lớn: giúp giảm thời gian truy xuất data</li></ul><p><strong>==&gt; CPU thiên về sử dụng Cache và điều khiển</strong></p><h3 id=\"cpuhideshortlatency\">CPU: Hide short latency</h3><p>Một trong những phương pháp giúp giảm độ trễ hoặc thời gian phản hồi của CPU là <strong>modest multithreading</strong>. Cách thức hoạt động của modest multithreading:</p><ul><li>CPU thực thi 1 công việc thì công việc đó sẽ được chia thành K task nhỏ </li><li>CPU tạo ra 1 vài shadow threads ( thread dự phòng ) </li><li>Các shadow threads sẽ xử lí 1 phần nhỏ của K task, phần còn lại sẽ do main threads xử lí</li><li>Khi các main threads gặp 1 vài vấn đề dẫn đến latency ( ví dụ như: đợi read data, đợi transfer data ) thì các main threads sẽ nhảy qua xử lí 1 phần nhỏ công việc mà shadow threads đang làm cho đến khi hết latency ( tức là khi data được read xong, các data đã được transfer xong ) thì sẽ nhảy về lại để làm tiếp. ( nên vì vậy mới có tên gọi là hide short latency )</li></ul><h3 id=\"gputhroughputorienteddesign\">GPU: Throughput-Oriented Design</h3><p>Là phương pháp thiết kế với mục tiêu là tăng khả năng xử lí <strong>1 lượng task lớn nhưng đơn giản</strong> trong thời gian ngắn. Vậy tại sao lại là xử lí nhiều task cùng 1 lúc trong 1 thời gian ngắn? Là vì GPU được thiết kế với số lượng core <strong>rất nhiều</strong> nhưng lại <strong>kém chất lượng</strong> hơn so với core của CPU, nên vì vậy mục tiêu của GPU là xử lí các task đơn giản nhưng số lượng nhiều ( giống như tôi yếu nhưng anh em tôi đông )</p><p>===&gt; Vì vậy GPU xử lí các task đơn giản nhưng số lượng lớn nên cần tăng khả năng xử lí 1 lượng lớn task trong thời gian ngắn</p><p>Như trong hình ta có thể thấy phần lớn diện tích là các đơn vị tính toán:</p><ul><li>Nhiều core: dẫn đến việc tính toán nhanh hơn ==&gt; để đáp ứng được nhu cầu cung cấp data cho việc tính toán nên GPU được thiết kế với 1 kiến trúc giúp cho bandwidth ( băng thông ) trở nên nhanh hơn và memory cũng nhiều hơn (bandwidth/memory của GPU hơn CPU rất nhiều )</li></ul><p><strong>==&gt; GPU dùng vào mục đích xử lí lượng lớn data  và song song</strong></p><h3 id=\"gpuhideveryhighlatency\">GPU: Hide very high latency</h3><p>một trong những phương pháp giúp tăng khả năng xử lí 1 lượng lớn task trong thời gian ngắn của GPU là sử dụng <strong>massive number of threads</strong> ( 1 lượng lớn threads ) </p><p>==&gt; có thể hiểu đơn giản là mình tăng số lượng task được thực thi tại 1 điểm thì tức là mình đã giảm được tổng thời gian cần thực hiện tất cả các task</p><h3 id=\"tmtt\">Tóm tắt:</h3><p>CPU xử lí các task phức tạp nhưng ít</p><p>GPU xử lí nhiều task nhưng đơn giản</p><p>&gt; CPU giống như là 1 chiếc siêu xe với 1 bộ mã lực siêu mạnh, GPU giống như là 1 chiếc xe bus siêu dài và nhiệm vụ là chở khách. Thì nếu chỉ chở 1 số lượng ít khách thì CPU sẽ nhanh hơn nhưng nếu số lượng khách nhiều thì GPU sẽ là lựa chọn tuyệt vời. <br/>&gt; <br/>&gt; Multithreads: chia 1 task lớn thành các task con và để nhiều threads xử lí ==&gt; short latency<br/>&gt; <br/>&gt; Massive threads: tạo ra nhiều threads để thực hiện nhiều task ==&gt; high latency</p><p><img src=\"https://images.viblo.asia/dd2e9b87-eb19-4ca8-9260-bc950cc652d3.png\" alt=\"Screenshot from 2023-07-13 10-06-26.png\" /></p><h4 id=\"mtchtthvvgpu\">Một chút thú vị về GPU</h4><p>Mỗi khi nhắc đến <strong>GPU</strong> là ta nhắc đến <strong>card đồ họa ( Graphics Card )</strong> vậy thì tại sao người ta lại đặt cái tên đó? Hồi xưa, khi ngành game nói riêng cũng như các ngành liên quan đến xử lí đồ họa nói chung đang ngày càng được nhiều người biết tới ==&gt; nhu cầu tăng cao nhưng chất lượng thì vẫn không có sự phát triển ( cung thì tăng còn cầu thì vẫn vậy ) lý do hết sức đơn giản: ví dụ 1 bức ảnh sắc nét và đẹp thì cũng cỡ 1600x900 ( này là con số mình lấy ví dụ nhưng các bạn có thể hình dung tất là CPU phải xử lí 1440000(1600x900) pixel tại 1 thời điểm và nhiệm vụ là video tức là frame tức là tại mỗi thời điểm phải xử lí nhiều bức ảnh có số lượng pixel như vậy ).</p><p>Mà như mình đã phân tich trên thì <strong>CPU nếu dùng để xử lí từng pixel 1 thì quá phí tài nguyên</strong> (  có thể hiểu đơn giản là for loop tới chết mà mỗi iteration ( lần lặp ) thì công việc lại đơn giản ==&gt; không tận dụng triệt để khả năng của CPU, giống như việc dùng siêu xe để chở khách ). Thì lúc này người ta mới phát minh ra <strong>Graphics card chỉ dành riêng cho 1 mục đích là xử lí pixel.</strong> Sau này ngày càng phát triển dẫn đến việc tính toán của GPU ngày càng ưu việt nên người ta mới áp dụng GPU vào nhiều lĩnh vực khác liên quan đến tính toán nên mới có cái tên là <strong>GPGPU ( General-Purpose tính toán trên Graphics Processing Units )</strong></p><h2 id=\"phntchcuhicuibi3\">Phân tích câu hỏi cuối bài 3</h2><p>Trước khi giải đáp câu hỏi thì mình sẽ đi qua 2 khái niệm <strong>SIMD</strong> và <strong>SIMT</strong></p><p><strong>CPU: SIMD ( Single Instruction, Multiple Data):</strong>  là một kiến trúc máy tính thường được sử dụng trong CPU với mục tiêu là làm sao tại mỗi instruction <strong>xử lí nhiều data nhất có thể</strong></p><p><strong>GPU: SIMT (Single Instruction, Multiple Threads):</strong> là một kiến trúc máy tính <strong>được phát triển bởi NVIDIA</strong> và được sử dụng trong GPU với mục tiêu là làm sao tại mỗi instruction  <strong>sử dụng nhiều threads nhất có thể</strong></p><p>&gt; Cả SIMD và SIMT đều là các kiến trúc được sử dụng trong việc xử lý dữ liệu song song trên các thiết bị tính toán như CPU và GPU. <br/>&gt; <br/>&gt; Thoạt nhìn thì SIMD và SIMT có vẻ giống nhau nhưng nó là 2 kiến trúc khác nhau ở 1 số điểm cũng như lý do tại sao CPU lại là SIMD và GPU là SIMT</p><p>Như đã đề cập: </p><ul><li>CPU: vì xử lí task phức tạp nên cơ chế của SIMD sẽ chia task phức tạp đó ra thành các task con và từ đó sẽ xử lí song song các task con</li><li>GPU: vì xử lí nhiều task đơn giản nên cơ chế của SIMT sẽ là xử lí song song các task lun</li></ul><p>Ví dụ: bài toán cộng 2 vector ( mỗi vector chứa N phần tử )</p><ul><li>SIMD: ở đây nhiệm vụ sẽ là <strong>thực hiện 1 bài toán cộng 2 vector</strong> và từ đó SIMD sẽ chia bài toán cộng 2 vector thành <strong>N bài toán con</strong> là cộng 2 phần tử và từ đó <strong>thực hiện song song N bài toán con này</strong></li><li>SIMT: ở đây dưới góc nhìn của SIMT thì mỗi vector chứa N phần tử sẽ là <strong>N bài toán độc lập</strong> tức là nhiệm vụ sẽ là <strong>thực hiện N bài toán cộng các phần tử</strong> ( tức là sẽ có N bài toán chứ không phải là N bài toán con ) và từ đó <strong>mình ( các coder ) sẽ tự chia các thread để xử lí song song N bài toán này</strong></li></ul><p>&gt; SIMD: <strong>máy tính sẽ tự chia</strong> 1 bài toán lớn ( cộng 2 vector ) thành N bài toán con<br/>&gt;<br/>&gt; SIMT: <strong>mình sẽ là người thực hiện chia</strong> các thread để xử lí N bài toán này</p><h3 id=\"phntchcuhi\">Phân tích câu hỏi</h3><p>Bài toán của chúng ta là <strong>in hello world 10 lần</strong> và vì là <strong>SIMT nên mình sẽ tự chia</strong> các thread để thực hiện việc in hello world này. Ở đây mình chia các thread thành 2 kiểu là <strong>&lt;&lt;&lt;1,10&gt;&gt;&gt;</strong> và <strong>&lt;&lt;&lt;2,5&gt;&gt;&gt;</strong> vì <strong>chỉ là 10 thread</strong> nên <strong>2 cách này là như nhau</strong> nhưng nếu bài toán là <strong>in hello world 64 lần</strong> và được biểu diễn là <strong>&lt;&lt;&lt;1,64&gt;&gt;&gt;</strong> và <strong>&lt;&lt;&lt;2,32&gt;&gt;&gt;</strong> thì lúc này <strong>sẽ có sự khác biệt</strong> ( là vì tại mỗi thời điểm trong 1 block chỉ thực hiện 32 warp ) nên nếu là &lt;&lt;&lt;1,64&gt;&gt;&gt; tức là sẽ tốn 2 đơn vị thời gian để xử lí xong 64 lần in hello world, còn &lt;&lt;&lt;2,32&gt;&gt;&gt; cũng chỉ tốn 1 đơn vị thời gian để xử lí. <br/>&gt; Mình có giải thích rõ hơn ở bài <a href=\"https://viblo.asia/p/lap-trinh-song-song-bai-bonus-2-cac-thuat-ngu-trong-lap-trinh-song-song-2oKLndZy4QO\">bonus 2</a> nằm ở phần các QUY TẮC </p><p>Tóm lại qua bài này các bạn đã hiểu rõ hơn về CPU cũng như GPU, và vì là cơ chế SIMT nên việc chia các thread 1 cách hợp lí sẽ rất là quan trọng nên vì vậy chúng ta phải biết dùng bao nhiêu thread cho mỗi block cho hợp lí.</p>","title":"[Lập trình song song] Bài 4: Cách thức hoạt động CPU-GPU","tags":["cpu","cuda","GPU","lập trình song song"],"created_at":1691865025000,"updated_at":1691983387000,"comments":[]}