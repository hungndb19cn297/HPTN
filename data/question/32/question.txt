{"content":"<p>Phuongne, Th4 04, 2020</p><hr /><h3 id=\"mu\">Mở đầu</h3><ul><li>Trước tiên để tìm hiểu về các hàm được cung cấp sẵn, mình sẽ đưa ra sơ đồ tổng quát của <em>Unity3D Documentation</em> sau.</li><li>Mặc định trong bài viết các gameObjects được active cùng một lúc nhé</li></ul><p><img src=\"https://images.viblo.asia/5929dae3-c24d-4860-b03c-d4afad9069dd.png\" alt=\"image.png\" />&lt;div align=\"center\"&gt;Monobehaviour Flowchart (Unity3D Documents)<br/>&lt;/div&gt;</p><h2 id=\"iinitialization\">I. Initialization</h2><p>Như chúng ta thấy ở bảng trên, Awake, OnEnable và Start nằm cùng một phần gọi là Initialization nhưng công dụng của chúng khác nhau như thế nào?, và chúng được gọi khi nào trong vòng đời của MonoBehaviour?</p><ul><li><strong>Awake():</strong> các hàm Awake đều được gọi trước <strong>TẤT CẢ</strong> các hàm Start của các <em>MonoBehaviour</em> có trong Scene (được enable cùng lúc) hay gọi ngay sau khi gameObject đó được sinh ra bằng hàm Instantiate().</li></ul><p>Awake chỉ được gọi một lần duy nhất trong vòng đời của một <em>MonoBehaviour</em></p><ul><li><strong>OnEnable():</strong> hàm này được gọi khi một gameObject được đổi trạng thái từ <em>deactive -&gt; active</em> hoặc khi enable Component và được gọi lần đầu tiên ngay sau hàm Awake của nó.</li></ul><p>&gt; “Vậy nếu có 2 gameObjects A và B thì thứ tự gọi có phải là Awake A -&gt; Awake B -&gt; OnEnable A -&gt; OnEnable B?”</p><p>Không, vào lúc active lần đầu tiên, thứ tự gọi như sau:</p><p><img src=\"https://images.viblo.asia/f6aa1813-5a27-4fa7-9ab7-7fc05a11a74d.png\" alt=\"image.png\" />&lt;div align=\"center\"&gt;Thứ tự gọi của Awake() và OnEnable() của 2 gameObjects bất kỳ&lt;/div&gt;</p><p>&gt; “Sao Awake của B gọi trước Awake của A vậy?”</p><p>Thứ tự gọi Awake trong Unity là random.</p><ul><li><strong>Start():</strong> hàm Start() được gọi sau OnEnable, trước khi các frames bắt đầu chạy hay trước các hàm Update. Cũng như Awake, nó chỉ được gọi một lần duy nhất.</li></ul><p>&gt; “Hàm Start còn có gì khác so với Awake nữa không?”</p><p>Có một điểm đặc biệt của hàm Awake, nó sẽ được gọi kể cả khi script <strong>KHÔNG</strong> được enable (xem ảnh dưới), trong khi Start thì sẽ không được gọi. Tuy nhiên trong trường hợp GameObject de-active thì không có hàm nào được gọi.</p><p><img src=\"https://images.viblo.asia/965a6153-eda8-471d-9feb-2affc4e65ed7.png\" alt=\"image.png\" />&lt;div align=\"center\"&gt;Checkbox enable-disable script&lt;/div&gt;</p><p>Như vậy, các hàm thuộc loại Initialization thường được sử dụng để khởi tạo các giá trị có sẵn hoặc cache các components (GetComponent), trong đó chỉ có OnEnable() có thể được gọi nhiều lần</p><h2 id=\"iigamelogic\">II. Game Logic</h2><p>Ở phần này mình sẽ không đề cập về <strong>Internal Animation Update</strong>, ta chỉ quan tâm đến phần này khi sử dụng StateMachineBehaviour.<br />Đại loại nếu MonoBehaviour được gắn vào vào các GameObject thì StateMachineBehaviour sẽ được gắn vào các animation state và cũng có các hàm tương tự để xử lý</p><ul><li><p><strong>Update():</strong> chắc hẳn hàm này đã quá quen thuộc khi chúng ta mới bắt đầu sử dụng Unity engine, Update được gọi mỗi lần vào mỗi frame và được xem như hàm xử lý chính của vòng lặp game.</p></li><li><p><strong>LateUpdate():</strong> LateUpdate() được gọi như Update, mỗi frame một lần, điểm khác biệt duy nhất là nó được gọi sau khi các hàm Update của tất cả các MonoBehaviour đã được thực thi xong.</p></li></ul><p>Một chức năng kinh điển của hàm này là khi sử dụng camera follow theo player, sau khi vị trí cũng như rotation của player đã được tính toán hoàn tất trong Update, thì ta sẽ LateUpdate vị trí và góc xoay của camera theo player, đảm bảo được độ chính xác cao.</p><p><em>yield Null, WaitForSeconds, WWW, StartCoroutine</em>,… được thực thi tiếp khi sử dụng ở phần Coroutine, có thể đọc bài <a href=\"https://viblo.asia/p/coroutine-trong-unity-la-gi-co-lien-quan-toi-threads-hay-khong-m2vJPe5ZLeK\">Coroutine trong Unity là gì?</a> để tham khảo thêm.</p><h2 id=\"iiiphysics\">## III. Physics</h2><ul><li><strong>FixedUpdate</strong>: Hàm này được gọi không phụ thuộc vào vòng lặp chính của game mà gọi theo vòng lặp của vật lý trong game, thường nó được gọi cố định vào mỗi 0.02s theo mặc định của project setting, con số này gọi là Fixed Timestep hay fixedDeltaTime.</li></ul><p><img src=\"https://images.viblo.asia/f734a660-d6db-4104-a30e-83f4d770180b.png\" alt=\"image.png\" />&lt;div align=\"center\"&gt;Điều chỉnh Fixed Timestep trong Project Settings&lt;/div&gt;</p><p>Vì vậy FixedUpdate có thể được gọi nhiều hơn một lần hoặc không gọi trong 1 frame tùy theo FPS của game</p><ul><li><strong>Internal Physics Update:</strong> Đây là vùng xử lý chính của Physics System trong unity được xử lý riêng mà chúng ta không can thiệp, với một số chức năng sẵn có như áp trọng lực, trigger các hàm va chạm, di chuyển các vật thể sử dụng vật lý (rigidbody, joints,…)</li></ul><p>Vùng này được thực thi sau FixedUpdate, vì vậy các xử lý liên quan tới vật lý thì chúng ta nên đặt ở trong FixedUpdate thay vì Update để Physics System của Unity có thể cập nhật vị trí và xét va chạm kịp thời.</p><p>Mình đã nói qua vấn đề lỗi này ở bài <a href=\"https://viblo.asia/p/co-ban-ve-rigidbody-trong-unity3d-qPoL77qkLvk/\">Cơ bản về Rigidbody</a>.</p><h2 id=\"ivdecommissioning\">IV. Decommissioning</h2><ul><li><p><strong>OnApplicationQuit()</strong>: cái tên cũng nói lên được công dụng của hàm này rồi, nó sẽ được gọi trước khi thoát game (hoặc tắt Play mode trong Unity Editor)</p></li><li><p><strong>OnDisable():</strong> hàm này tương ứng với OnEnable mà mình đã đề cập ở trên, có thể được gọi nhiều lần nếu GameObject active-deactive nhiều lần (hoặc enable-disable Component gắn vào GameObject)</p></li><li><p><strong>OnDestroy():</strong> cuối cùng là OnDestroy, hàm này sẽ được gọi ở cuối frame, đồng nghĩa với việc khi xóa một GameObject trong scene (bằng script hoặc các sự kiện như thoát game, chuyển scene,…) hay sử dụng hàm <strong>Destroy(gameObject)</strong>, nó sẽ không xóa ngay lập tức mà phải đến cuối frame đó nó mới được dọn dẹp.</p></li></ul><p>Để dọn dẹp một GameObject ngay lập tức mà không cần delay tới cuối frame, có thể sử dụng DestroyImmediate, tuy nhiên Unity khuyến cáo là chỉ nên sử dụng khi debug và không nên sử dụng trong game.</p><h2 id=\"claims\">Claims</h2><p>Bài viết được đăng vào 2020, chỉ có giá trị tham khảo các bạn nhé.</p><h2 id=\"ngunthamkho\">Nguồn tham khảo</h2><ul><li><a href=\"https://docs.unity3d.com/Manual/ExecutionOrder.html\">Order of Execution for Event Functions</a></li></ul>","title":"Awake, Start và một số hàm cơ bản trong MonoBehaviour","tags":["Unity3d"],"created_at":1690594628000,"updated_at":1692538925000,"comments":[]}