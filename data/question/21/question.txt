{"content":"<p>Phuongne, Th3 07, 2021</p><hr /><p>&gt; Bài trước: <a href=\"https://viblo.asia/p/unity-basic-35-lam-quen-voi-scripts-geometry-start-awake-update-BQyJKReR4Me\">C3. Làm quen với Scripts (Geometry, Start, Awake, Update,…)</a></p><p>Về bài viết, chúng ta sẽ đi nhanh qua các concepts cơ bản nhất: reference, public, collision, rigidbody,… trong Unity, ở đây mình không đi sâu cũng như rõ ràng từng concept vì vậy bạn có thể tham khảo dựa trên các keywords trong bài này. Ở trên <strong>lớp training</strong>, mình sẽ nói kỹ từng phần hơn nhé.</p><h2 id=\"thamchiuticomponentslg\">Tham chiếu tới components là gì?</h2><p>Mỗi gameObject đều có một loạt các components định nghĩa nó và component cơ bản nhất của gameObject là <strong>Transform</strong> nhằm định nghĩa vị trí của object đó trong thế giới game.</p><p>Đa số các components đều có các giá trị được public ra ở Inspector giúp bạn chỉnh sửa dễ dàng trên Unity Editor.</p><p>Vậy làm sao để bạn chỉnh sửa các thông số này khi runtime – game đang chạy?</p><p>Thay vì sửa tay các giá trị trên tab Inspector, chúng ta sẽ truy cập vào component đó bằng scripts và sửa giá trị thì sẽ dễ dàng và linh hoạt hơn.</p><p>Giả sử bạn có một MonoBehaviour tên là <strong>PlayerController</strong> và muốn tham chiếu tới component <strong>Rigidbody</strong> trong cùng một gameObject để thay đổi vận tốc. Unity hỗ trợ bạn hàm <code>GetComponent&amp;lt;T&amp;gt;();</code> để PlayerController có thể tham chiếu tới Rigidbody:</p><pre><code class=\"cs language-cs\">public class PlayerController : MonoBehaviour<br/>{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private void Awake()<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// tham chiếu tới Rigidbody trong cùng gameObject.<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Rigidbody rigid = GetComponent&amp;lt;Rigidbody&amp;gt;();<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}<br/>}<br/></code></pre><p>Biến rigid của bạn sẽ là instance của Rigidbody <strong>gắn trên cùng gameObject</strong>, bạn có thể sử dụng hàm GetComponent&lt;T&gt;(); để lấy bất kỳ component nào liên kết với gameObject này.</p><p>&gt; <em>“Ủa nếu gameObject mình không có Rigidbody thì sao?”</em></p><p>Giá trị biến rigid sẽ bằng null.</p><p>Đồng thời đối với component <strong>Transform</strong>, các bạn không cần phải GetComponent\\&lt;Transform\\&gt;();, trong mỗi MonoBehaviour đều tham chiếu sẵn tới nó. Như vậy bạn chỉ cần truy cập trực tiếp:</p><pre><code class=\"cs language-cs\">public class PlayerController : MonoBehaviour<br/>{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;private void Awake()<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;transform.position = Vector3.zero; // không lỗi<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}<br/>}<br/></code></pre><p>&gt; “<em>Sao trong class Component cũng có rigidbody như transform mà mình không sử dụng?</em>“</p><p>Không như transform, rigidbody bạn phải sử dụng <code>GetComponent&amp;lt;Rigidbody&amp;gt;()</code> bởi thuộc tính này đã lỗi thời: “Property rigidbody has been deprecated. Use GetComponent() instead. (UnityUpgradable)”. Các phiên bản hoặc tài liệu cũ vẫn có thể sử dụng như vậy.</p><h2 id=\"ccbinpublicvunityeditor\">Các biến public và Unity Editor</h2><p>Một trong những tính năng “đỉnh cao” nhất của Unity Editor đó là khả năng show các biến config của Component cho chúng ta chỉnh sửa, giống như component Transform cho phép bạn chỉnh sửa thông số của: <strong>position</strong>, <strong>rotation</strong> và <strong>scale</strong>.</p><p><img src=\"https://images.viblo.asia/8292cc80-1d0f-47e0-908c-8b2425e43f1e.png\" alt=\"image.png\" />&lt;div align=\"center\"&gt; Transform component&lt;/div&gt;</p><p>Chúng ta cũng có thể kiểm soát được biến nào cần show ra và biến nào cần ẩn đi bằng access modifier: public, protected, private,…</p><p>Giả sử component PlayerController cần show 2 biến để bạn điều chỉnh trên Editor:</p><pre><code class=\"cs language-cs\">public class PlayerController : MonoBehaviour<br/>{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public float speed = 5.0f;<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public float sensitive = 0.8f;<br/>}<br/></code></pre><p><img src=\"https://images.viblo.asia/2f5b47fa-651c-4a1d-b4a6-6662a552bf75.png\" alt=\"image.png\" /></p><p>&gt; <em>“Sao phải chỉnh sửa thông số trên Editor mà không phải trong scripts?”</em></p><p>Có rất nhiều các thông số mà bạn phải config trước cho component, chúng ta đưa nó lên Editor để có thể cân bằng đến khi hợp ý chúng ta. Nếu bạn sửa trong code, bạn cần phải compile code mới có thể test được sự thay đổi.</p><p>Đồng thời việc này sẽ rất thuận tiện cho các bạn <strong>Game Designer</strong> chỉnh sửa ngay trên Editor, bởi có thể họ không biết code hoặc cấu trúc code của bạn hơi rối đối với họ.</p><p>Nhưng <strong>đừng</strong> lạm dụng quá biến <strong>public</strong> chỉ vì chúng có thể show ra trên tab Inspector của Editor nhé. Bạn có thể sử dụng biến private và attribute [SerializeField] như <a href=\"https://viblo.asia/p/serializefield-header-va-mot-so-attributes-trong-unity3d-x7Z4DYKoJnX\">SerializeField, Header và một số attributes trong Unity3D</a></p><h2 id=\"thamchiuvtruycpcomponentsgameobjects\">Tham chiếu và truy cập Components/ GameObjects</h2><p>Các bạn tự phân biệt tham chiếu tới <strong>Components</strong> và tham chiếu tới <strong>GameObjects</strong> nhé.</p><p>Ở trên mình đã nói về concept tham chiếu giữa các components, chúng ta sẽ đi qua các cách phức tạp hơn một chút để tham chiếu.</p><h3 id=\"taglg\">Tag là gì?</h3><p>Trong Unity, chúng ta có một khái niệm gọi là <strong>Tags</strong>, bạn có thể đánh nhiều gameObjects cùng một tag, như kiểu bạn phân loại gameObject vậy.</p><p>Ví dụ, enemy có nhiều loại <strong>A</strong>, <strong>B</strong>, <strong>C</strong>, <strong>D</strong> nhưng mình có thể phân biệt chúng đều là Enemy bằng tag: <strong>Enemy</strong>.</p><p><img src=\"https://images.viblo.asia/5537aa8a-688b-40bc-b33a-fb4943395c69.png\" alt=\"image.png\" /></p><p>Bạn có thể set tag cũng như thêm tag mới của một gameObject ở trên Unity Editor, ngay dưới tên của gameObject trên tab Inspector nhé.</p><h3 id=\"thamchiubngtnhoctag\">Tham chiếu bằng tên hoặc Tag</h3><p>Như vậy một gameObject sẽ liên kết với <strong>một tên</strong> và <strong>một tag</strong>, đồng thời cả 2 yếu tố này có thể giúp bạn tham chiếu tới gameObject hoặc components.</p><p>Đầu tiên mình sẽ tham chiếu tới các GameObjects khác nhé:</p><pre><code class=\"cs language-cs\">private void Awake()<br/>{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;// tham chiếu tới gameObject có tên là Main Camera<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GameObject camera = GameObject.Find(\"Main Camera\");<br/>}<br/></code></pre><p>Hoặc sử dụng tag:</p><pre><code class=\"cs language-cs\">GameObject camera = GameObject.FindGameObjectWithTag(\"MainCamera\");<br/></code></pre><p>Và lưu ý rằng, để biến camera không bằng <strong>null</strong> thì Camera phải có tag là MainCamera nhé, thông thường mặc định khi tạo scene thì camera sẽ có tag “MainCamera” sẵn cho bạn.</p><p><img src=\"https://images.viblo.asia/529e6a2c-6e17-4ff2-afad-6ef2ffe68651.png\" alt=\"image.png\" /></p><p>&gt; <em>“Vậy nếu có nhiều gameObject cùng tags thì sao?”</em></p><p>Thì hàm sẽ trả về gameObject đầu tiên mà nó query được, nếu bạn muốn lấy hết tất cả các objects có tags chỉ định thì:</p><pre><code class=\"cs language-cs\">GameObject [] enemies = GameObject.FindGameObjectsWithTag(\"Enemy\");<br/></code></pre><p>Có rất nhiều hàm tìm kiếm các GameObject cũng như tìm kiếm Components bạn có thể search trên trang documentation của Unity.</p><p>Tuy nhiên bạn cần lưu ý rằng, các lệnh tìm kiếm tương đối chậm (vẫn nhanh nhưng chậm so với các API khác), vì vậy mình khuyến khích nên sử dụng chúng trong các hàm khởi tạo chỉ gọi một lần như <code>Start()</code>, <code>Awake()</code> và <strong>không</strong> nên đặt trong Update(), for, while,…</p><p>&gt; <em>“Còn lưu ý nào không?”</em></p><p>Khác với tên của file trong folder, tên của gameObject không phải là duy nhất và chúng <strong>có thể trùng nhau</strong>, vì vậy không nên xem tên gameObject như là id để phân biệt các gameObject nhé.</p><h3 id=\"truycpthuctnhcacomponentskhc\">Truy cập thuộc tính của components khác</h3><p>Thông thường, đây là một yêu cầu cơ bản nhất trong game, <strong>component A</strong> cần biết thông tin của <strong>component B</strong>.</p><p>Giả sử như gameObject <strong>Enemy</strong> đang đuổi đánh <strong>Player</strong> chẳng hạn, component <strong>EnemyAI</strong> cần phải biết vị trí của <strong>Player</strong> để di chuyển tới mà vị trí của Player được lưu trữ trong Transform. Như vậy EnemyAI cần tham chiếu tới <strong>Transform</strong> của Player để lấy được vị trí.</p><p>Chúng ta sẽ thực hiện 3 công việc cho EnemyAI: tham chiếu tới gameObject <strong>Player</strong>, tham chiếu tới component <strong>Transform</strong> của gameObject Player và truy cập thuộc tính <strong>position</strong>:</p><pre><code class=\"cs language-cs\">public class EnemyAI : MonoBehaviour<br/>{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;public GameObject player; // the player object<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void Start()<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;GameObject player = GameObject.Find(\"Player\"); // (1)<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void Update()<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;MoveTo(player.transform.position); // (2), (3)<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;void MoveTo(Vector3 target)<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//...<br/>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}<br/>}<br/></code></pre><h2 id=\"xlvachm\">Xử lý va chạm</h2><p>Game của chúng ta hoạt động theo hướng sự kiện (<strong>event driven</strong>), khi có một sự kiện xảy ra, chúng ta xử lý nó.</p><h3 id=\"colliderlg\">Collider là gì?</h3><p>Một vài events được tạo bởi người dùng: input keyboard, một vài lại xảy ra theo một khoảng thời gian nhất định: Update(), và một vài events sẽ xảy ra do chính game của chúng ta.</p><p>Điều mình muốn nói đến ở đây là sự kiện <strong>va chạm</strong> giữa các gameObjects, khi có va chạm xảy ra, chúng ta sẽ muốn xử lý sự kiện này. Giả sử viên đạn va chạm với enemy chẳng hạn, bạn sẽ phải viết code để làm nổ viên đạn, xóa viên đạn, trừ máu enemy, kiểm tra máu enemy &gt; 0, xóa enemy,…</p><p>Và để 2 gameObject va chạm, điều kiện cần của chúng là phải có một component gọi là <strong>Collider</strong> (bạn có thể gọi là <strong>hit box</strong> cho quen thuộc), các Collider sẽ tạo ra các khối hình, nếu các khối hình này đè lên nhau thì chúng phát ra sự kiện va chạm.</p><h3 id=\"2loicollidercollisionvtrigger\">2 loại collider: collision và trigger</h3><p>Collider chia thành 2 loại: <strong>collisions</strong> và <strong>triggers</strong>.</p><p>Bạn hãy tưởng tượng <strong>collision</strong> là một khối vật thể cứng, va chạm vào thì gameObject sẽ bị bật ra. Trong khi Trigger là một vật thể không chạm được như tia laser, màn sương hoặc con ma, bạn vẫn có thể phát hiện tia laser đang “chĩa” vào bạn mà không hề có va chạm vật lý nào xảy ra.</p><p>Giả sử, khi Player chạy và va chạm với cánh cửa, có thể player sẽ bị bật ra hoặc/ và cánh cửa bị vỡ ra, như vậy chúng va chạm theo kiểu <strong>collision</strong>.</p><p>Giả thiết khi Player đi vào căn phòng không có cửa, bạn vẫn có thể phát hiện ra khi Player đi vào phòng bằng cách đặt một cách cửa vô hình, chúng va chạm theo kiểu <strong>trigger</strong>.</p><p>Các hàm giúp bạn xử lý bao gồm:</p><ul><li><strong>Collision</strong>: void OnCollisionEnter(), void OnCollisionStay(), void OnCollisionExit();</li><li><strong>Trigger</strong>: void OnTriggerEnter(), void OnTriggerStay(), void OnTriggerExit();</li></ul><p>Nếu là game 2D thì bạn thêm 2D vào cuối tên hàm nhé.</p><p>&gt; <em>“Tại sao cả 2 gameObjects của mình có component Colilders mà chúng không phát hiện va chạm vậy?”</em></p><p>Đúng vậy, 2 gameObjects chỉ có Collider mà không có Rigidbody ở một trong 2 sẽ không có va chạm, bởi chúng không tính là xử lý vật lý nếu không có Rigidbody.</p><h3 id=\"rigidbodylg\">Rigidbody là gì?</h3><p>Trước đây, mình sẽ đề cập tới <strong>Rigidbody</strong> nhưng không nói rõ ràng nó là gì và chúng ta làm được gì với component này.</p><p>Lại tưởng tượng các gameObject trên Scene của bạn là các objects “tĩnh”, bởi chúng không sinh động và tương tác với nhau bằng <strong>lực</strong> và Rigidbody sẽ giúp các objects này “thật” hơn.</p><p>Khi một gameObject được gắn thêm Rigidbody, chúng sẽ trở thành một thực thể sống, chịu tác động của trọng lực, bị lực tác động, tác động lực lên vật khác, có trọng lượng,…, giả sử mình đặt trọng lượng của nó bằng 10f chẳng hạn:</p><pre><code class=\"cs language-cs\">GetComponent&amp;lt;Rigidbody&amp;gt;().mass = 10.0f;<br/></code></pre><p>Và bạn không cần phải tự mình định nghĩa va chạm là như thế nào? Khi va chạm thì gameObject bật ra như thế nào? Tất cả đã có Unity Engine lo việc này, việc của chúng ta là xử lý sau khi va chạm.</p><h3 id=\"dichuynvtl\">Di chuyển vật lý</h3><p>Để di chuyển một tác nhân vật lý (có <strong>rigidbody</strong>) chúng ta không sử dụng transform, mà thường sử dụng lực bằng cách AddForce(…):</p><pre><code class=\"cs language-cs\">rb.AddForce(Vector3.up * 10f) ; // tác động một lực hướng lên<br/></code></pre><p>&gt; “Tại sao không di chuyển bằng component Transform?”</p><p>Bạn có thể đọc thêm ở bài <a href=\"https://viblo.asia/p/co-ban-ve-rigidbody-trong-unity3d-qPoL77qkLvk\">Cơ bản về Rigidbody trong Unity3D</a></p><p>Rất nhiều người sử dụng cách này để tạo lực một cách tự nhiên nhất, tuy nhiên để kiểm soát tốc độ của vật một cách ổn định, mình thường sử dụng <code>.velocity</code>:</p><pre><code class=\"cs language-cs\">GetComponent&amp;lt;Rigidbody&amp;gt;().velocity = new Vector3(0, 10, 0);<br/></code></pre><p>Cách này sẽ làm gameObject di chuyển không tự nhiên bằng AddForce, tuy nhiên mình có thể kiểm soát tốc độ tốt hơn.</p><h3 id=\"kinematic\">Kinematic</h3><p>Trong trường hợp các bạn không muốn vật bị tác động bởi lực, như mô phỏng thang máy chẳng hạn, bạn có thể đặt kiểu body của Rigidbody là Kinematic.</p><p>Như vậy vật sẽ không hẳn di chuyển theo engine vật lý của Unity, bạn có thể điều khiển nó trong scripts đồng thời giảm đi tài nguyên mà Unity phải xử lý.</p><p>Bạn vẫn có thể nhận được các events va chạm nhé.</p><h3 id=\"static\">Static</h3><p>Một trong những cách cực kỳ tối ưu cho vật lý là kiểu body <strong>Static</strong>, đối với những object không di chuyển như tòa nhà (building), mặt đất (ground),… bạn có thể đặt nó là <strong>Static</strong>.</p><p>Lưu ý rằng 2 objects static thì <strong>không</strong> va chạm nhau nhé.</p><p>Đồng thời, trong lúc chạy game, bạn cũng có thể chuyển từ một object dynamic sang object static và ngược lại, tuy nhiên trong Unity documentation khuyến cáo rằng việc này <strong>khá nguy hiểm</strong> bởi cách mà hệ thống vật lý của Unity xử lý.</p><h2 id=\"claims\">Claims</h2><p>Bài viết được đăng vào 2021, chỉ có giá trị tham khảo các bạn nhé ;)</p><h2 id=\"cuibivit\">Cuối bài viết</h2><p>Phần vật lý trong Unity có thể sẽ gây khó khăn cho các bạn, vì vậy nên tham khảo thêm bài <a href=\"https://viblo.asia/p/co-ban-ve-rigidbody-trong-unity3d-qPoL77qkLvk\">Cơ bản về Rigidbody trong Unity3D</a> để hiểu rõ hơn nhé.</p><p>&gt; Bài tiếp theo: <a href=\"https://viblo.asia/p/unity-basic-55-lam-quen-voi-scripts-events-instantiate-destroy-coroutines-pgjLNmpwJ32\">C5. Làm quen với Scripts (Events, Instantiate, Destroy, Coroutines,…)</a></p>","title":"Unity Basic (4/5): Làm quen với Scripts (Reference, public, Collision, Rigidbody,…)","tags":["Unity3d"],"created_at":1690705182000,"updated_at":1692496923000,"comments":[]}