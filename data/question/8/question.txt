{"content":"<p>Xin chào, mình thích viết ngắn và đi thẳng vấn đề 😴. Ở đây có tất cả những thứ bạn nên biết về Python threading.</p><h1 id=\"1threadinglmg\">1. Threading để làm gì?</h1><p><strong>Để xử lý đồng thời!</strong>Một cách mặc định, Python sẽ xử lý từ trên xuống. Do đó, tại một thời điểm chỉ có một đoạn mã được thực thi. Lấy ví dụ đoạn code sau:</p><pre><code class=\"python language-python\">def process_data(name: str, count: int):<br/>    print(f\"Starting {name}...\")<br/>    for i in range(count):<br/>        print(name, i+1, sep=\": \")<br/>if __name__==\"__main__\":<br/>    process_data(\"Thread-1\", 5)<br/>    process_data(\"Thread-2\", 10)<br/></code></pre><p>Ở đây, ta muốn chạy hàm <code>process_data</code> 2 lần, mỗi lần truyền vào một tham số khác nhau. Python sẽ thực thi từ trên xuống, tức là chạy hàm này với bộ tham số <code>(\"Thread-1\", 5)</code> trước, sau khi thực thi xong thì bắt đầu chạy hàm này với bộ tham số <code>(\"Thread-2\", 10)</code>. Kết quả trả ra sẽ là:</p><pre><code class=\"bash language-bash\">Starting Thread-1...<br/>Thread-1: 1<br/>Thread-1: 2<br/>Thread-1: 3<br/>Thread-1: 4<br/>Thread-1: 5<br/>Starting Thread-2...<br/>Thread-2: 1<br/>Thread-2: 2<br/>Thread-2: 3<br/>Thread-2: 4<br/>Thread-2: 5<br/>Thread-2: 6<br/>Thread-2: 7<br/>Thread-2: 8<br/>Thread-2: 9<br/>Thread-2: 10<br/></code></pre><p>Vậy nếu ta muốn chạy đồng thời hàm <code>process_data</code> với 2 bộ tham số trên cùng 1 lúc thì sao? Bởi rõ ràng việc chờ nhau để thực thi một cách tuần tự ở đây là không cần thiết. Threading sẽ giúp chúng ta xử lý vấn đề này.</p><h1 id=\"2threads\">2. Threads</h1><p>Để có thể tạo nhiều threads, ta sẽ sử dụng thư viện <code>threading</code>, 1 thư viện built-in của Python. Dưới đây là đoạn code để giúp hàm <code>process_data</code> có thể chạy đồng thời trong 2 threads khác nhau với thư viện này:</p><pre><code class=\"python language-python\">import time<br/>import threading<br/>def process_data(name: str, count: int):<br/>    print(f\"Starting {name}...\")<br/>    for i in range(count):<br/>        print(name, i+1, sep=\": \")<br/>        time.sleep(1)<br/>if __name__==\"__main__\":<br/>    thread_one = threading.Thread(target=process_data, args=(\"Thread-1\", 10))<br/>    thread_two = threading.Thread(target=process_data, args=(\"Thread-2\", 5))<br/>    thread_one.start()<br/>    time.sleep(3)<br/>    thread_two.start()<br/>    thread_one.join()<br/>    thread_two.join()<br/></code></pre><ul><li>Đoạn code <code>threading.Thread()</code> nhằm tạo ra một thead mới (= <code>asyncio.create_task</code> khi xử lý bất đồng bộ với <code>asyncio</code>). Nhớ rằng ở đây ta mới <strong>tạo ra</strong> chứ chưa chạy. </li><li>Thread sẽ thực sự chạy khi gọi <code>thread_one.start()</code>. </li><li><code>thread_one.join()</code>, việc gọi hàm này giúp cho chương trình chờ cho tới khi 2 threads được thực thi xong thì mới thực hiện đoạn code bên dưới (nếu có), =<code>await</code> khi xử lý bất đồng bộ (mình sẽ sớm ra bài về bất đồng bộ nha 😁).<br/>Khi <code>thread_one</code> được <code>start()</code> với tham số <code>(\"Thread-1\", 10)</code>, nó sẽ mất tổng cộng 10s để chạy xong (do với mỗi giá trị của biến <code>count</code> thì sleep 1s). Nhìn vào đoạn chương trình ở hàm <code>main</code>, ta thấy sau khi start <code>thread_one</code> sẽ chỉ chờ nó 3s, sau đó start <code>thread_two</code> nên chắc mọi người cũng dễ dàng đoán được là <code>thread_one</code> mới chạy được 3s (mới in ra được đến số 3 (trên tổng cộng count=10 số cần in) thì <code>thread_two</code> chen vào, chiếm quyền in. Lúc này 2 thread sẽ cùng đồng thời in các giá trị ra màn hình.<br/>Kết quả như sau:</li></ul><pre><code class=\"bash language-bash\">Starting Thread-1...<br/>Thread-1: 1<br/>Thread-1: 2<br/>Thread-1: 3<br/>Starting Thread-2...<br/>Thread-2: 1<br/>Thread-1: 4<br/>Thread-2: 2<br/>Thread-1: 5<br/>Thread-2: 3<br/>Thread-1: 6<br/>Thread-2: 4<br/>Thread-1: 7<br/>Thread-2: 5<br/>Thread-1: 8<br/>Thread-1: 9<br/>Thread-1: 10<br/></code></pre><p>Tèn ten, đúng như kỳ vọng!</p><h1 id=\"3khcgbtngb\">3. Khác gì bất đồng bộ?</h1><p>Bất đồng bộ (<strong>asynchronous</strong>) cho phép xử lý nhiều task <strong>trên cùng một thread</strong>, <strong>threading</strong> cho phép đẻ ra <strong>nhiều thread khác nhau</strong> để chạy song song.<br/>Thông thường, thì khi 1 task nặng đang chạy sẽ block task khác, do đó async sẽ dùng 1 cơ chế (là event loop, nếu bạn không hiểu thì kệ nó đi, haha) để cho phép 1 task đang thực thi nhưng chương trình vẫn có thể <strong>nhận task khác về để thực thi</strong> (cho phép nhận thui nhá, còn vẫn phải chờ task trước xong đã, 1 thread mà). Còn threading là cho phép xử lý song song đồng thời luôn.</p><h1 id=\"4lock\">4. Lock</h1><p>Hơi ngược đời chút, làm cách nào để chờ 1 thread chạy xong thì mới cho thread khác chạy? (Dù mục đích thread là ngăn điều này 😅). Câu trả lời là dùng <strong>lock</strong> (<code>threading.Lock</code>).<br/>Tuy nhiên trước khi nghiên cứu <strong>lock</strong>, ta thấy cũng có thể dùng <code>thread.join()</code> để chờ 1 thread thực thi xong như trên mình có nói. <br/>VD đoạn code sau:</p><pre><code class=\"python language-python\">import time<br/>import threading<br/>def counter(limit: int, name: str):<br/>    for i in range(limit):<br/>        time.sleep(0.5)<br/>        print(name, i+1, sep=\": \")<br/>def task1():<br/>    counter(5, \"T-1\")<br/>def task2():<br/>    counter(5, \"T-2\")<br/>def main():<br/>    thread1 = threading.Thread(target=task1)<br/>    thread2 = threading.Thread(target=task2)<br/>    thread1.start()<br/>    thread1.join()<br/>    thread2.start()<br/>    thread2.join()<br/>if __name__==\"__main__\":<br/>    main()<br/></code></pre><p>Sau khi <code>thread1</code> được <code>start</code>, ta dùng <code>thread1.join()</code> để chờ cho <code>thread1</code> này thực thi xong thì mới <code>thread2.start()</code>.<br/>Do đó, kết quả là:</p><pre><code class=\"bash language-bash\">T-1: 1<br/>T-1: 2<br/>T-1: 3<br/>T-1: 4<br/>T-1: 5<br/>T-2: 1<br/>T-2: 2<br/>T-2: 3<br/>T-2: 4<br/>T-2: 5<br/></code></pre><p>Great! Tuy nhiên, nhiều người lại không thích dùng <code>join()</code> (vì không có <code>join()</code> thì code nó vẫn chạy 😎). Lúc này ta sẽ dùng <code>lock</code> như đoạn code dưới:</p><pre><code class=\"python language-python\">import time<br/>import threading<br/>lock = threading.Lock()<br/>def counter(limit: int, name: str):<br/>    for i in range(limit):<br/>        time.sleep(0.5)<br/>        print(name, i+1, sep=\": \")<br/>def task1():<br/>    lock.acquire()<br/>    counter(5, \"T-1\")<br/>    lock.release()<br/>def task2():<br/>    lock.acquire()<br/>    counter(5, \"T-2\")<br/>    lock.release()<br/>def main():<br/>    thread = threading.Thread(target=task1)<br/>    thread2 = threading.Thread(target=task2)<br/>    thread.start()<br/>    thread2.start()<br/>if __name__==\"__main__\":<br/>    main()<br/></code></pre><ul><li>Trong hàm <code>task1</code>, <code>lock.acquire()</code> sẽ nói rằng: ê, chỉ chạy thread nào giữ lock này thôi nhá, bao giờ lock này được <code>release()</code> thì mới đến thread khác.</li><li>Trong hàm <code>task2</code> cũng là  <code>acquire()</code> lock nhưng sẽ khác với lock của <code>task1</code> (mỗi lần <code>lock.acquire()</code> sẽ có 1 lock khác nhau, chỉ áp dụng với thread đó cho tới khi được <code>release</code> thì không còn nữa).</li><li>Lưu ý là ở đây task nào cũng phải <code>acquire</code> 1 lock thì nó mới bị lock nha, chứ nếu chỉ <code>acquire</code> ở <code>task1</code> và bỏ ở <code>task2</code> thì <code>task2</code> sẽ không bị lock. Do cơ chế của <code>lock</code> thôi: <code>lock</code> sẽ đảm bảo <strong>tại một thời điểm chỉ có 1 thread được giữ lock</strong> và chạy, do đó nó chỉ quản lý được các thread được gán lock, chứ nếu không gán lock thì nó cũng chịu.<br/>Yes, và đây là kết quả, giống hệt dùng <code>join()</code> dù không dùng <code>join()</code> 😳:</li></ul><pre><code class=\"bash language-bash\">T-1: 1<br/>T-1: 2<br/>T-1: 3<br/>T-1: 4<br/>T-1: 5<br/>T-2: 1<br/>T-2: 2<br/>T-2: 3<br/>T-2: 4<br/>T-2: 5<br/></code></pre><p>Thế nếu ta tạo 1 thread mới trong chính <code>thread2</code> thì điều gì sẽ xảy ra? Xét đoạn code:</p><pre><code class=\"python language-python\">import time<br/>import threading<br/>lock = threading.Lock()<br/>def counter(limit: int, name: str):<br/>    for i in range(limit):<br/>        time.sleep(0.5)<br/>        print(name, i+1, sep=\": \")<br/>def task1():<br/>    lock.acquire()<br/>    counter(5, \"T-1\")<br/>    lock.release()<br/>def task2():<br/>    lock.acquire()<br/>    thread3 = threading.Thread(target=task3)<br/>    thread3.start()<br/>    counter(5, \"T-2\")<br/>    lock.release()<br/>def task3():<br/>    counter(5, \"T-3\")<br/>def main():<br/>    thread = threading.Thread(target=task1)<br/>    thread2 = threading.Thread(target=task2)<br/>    thread.start()<br/>    thread2.start()<br/>if __name__==\"__main__\":<br/>    main()<br/></code></pre><ul><li><code>thread3</code> (chạy <code>task3</code>) được khai báo và <code>start()</code> trong chính <code>task2</code>.</li><li>Khi này, <code>task2</code> và <code>task3</code> sẽ có thể xảy ra đồng thời, và cùng giữ lock, trong khi <code>task1</code> thì phải độc lập. Hãy xem kết quả là hiểu ngay:</li></ul><pre><code class=\"bash language-bash\">T-1: 1<br/>T-1: 2<br/>T-1: 3<br/>T-1: 4<br/>T-1: 5<br/>T-3: 1<br/>T-2: 1<br/>T-3: 2<br/>T-2: 2<br/>T-3: 3<br/>T-2: 3<br/>T-3: 4<br/>T-2: 4<br/>T-3: 5<br/>T-2: 5<br/></code></pre><p>OK, khó hơn chút này, đoạn code dưới đây tạo ra một <code>thread</code> có <code>acquire</code> lock (là <code>thread2</code>) trong 1 thread <code>acquire</code> lock (là <code>thread1</code>). Hãy đoán xem điều gì sẽ xảy ra:</p><pre><code class=\"python language-python\">import time<br/>import threading<br/>lock = threading.Lock()<br/>def counter(limit: int, name: str):<br/>    for i in range(limit):<br/>        time.sleep(0.5)<br/>        print(name, i+1, sep=\": \")<br/>def task1():<br/>    lock.acquire()<br/>    thread2 = threading.Thread(target=task2)<br/>    thread2.start()<br/>    counter(5, \"T-1\")<br/>    lock.release()<br/>def task2():<br/>    lock.acquire()<br/>    counter(5, \"T-2\")<br/>    lock.release()<br/>def main():<br/>    thread1 = threading.Thread(target=task1)<br/>    thread1.start()<br/>if __name__==\"__main__\":<br/>    main()<br/></code></pre><p>Hãy xem kết quả nhé:</p><pre><code class=\"bash language-bash\">T-1: 1<br/>T-1: 2<br/>T-1: 3<br/>T-1: 4<br/>T-1: 5<br/>T-2: 1<br/>T-2: 2<br/>T-2: 3<br/>T-2: 4<br/>T-2: 5<br/></code></pre><p>Đơn giản thôi, <code>thread2</code> có <code>acquire</code> lock trong <code>thread1</code> nhưng mà lock đang bị <code>thread1</code> giữ, chưa được <code>release</code> nên nó phải chờ cho <code>thread1</code> thực thi cho tới khi nó <code>release</code> lock, rồi nó mới có lock để thực thi.<br/>=&gt; Từ đây có thể đoán được là nếu bỏ <code>lock.release()</code> trong <code>task1</code> thì <code>task2</code> sẽ không bao giờ có cơ hội để thực thi và chương trình sẽ phải đợi mãi mãi (hãy thử nhé!).</p><h1 id=\"5daemonthread\">5. Daemon Thread</h1><p>Là loại thread có <strong>quyền ưu tiên thấp</strong>. Nó chỉ được giữ để thực thi khi có ít nhất 1 thread đang sống, còn không thì: bạn bè chết hết rồi, nó sẽ chết theo.<br/>Hãy xem đoạn code tạo daemon thread dưới:</p><pre><code class=\"python language-python\">import threading<br/>import time<br/>def infinite_loop():<br/>    while True:<br/>        print(time.time())<br/>        time.sleep(1)<br/>if __name__==\"__main__\":<br/>    thread = threading.Thread(target=infinite_loop, daemon=True)<br/>    thread.start()<br/></code></pre><p>Mặc định khi <code>threading.Thread()</code>, ta tạo ra 1 thread có quyền ưu tiên cao (<code>daemon=False</code>), nên nếu muốn tạo daemon thì ta chỉ định như đoạn code trên.</p><ul><li>Nếu không có <code>daemon=True</code>, hàm <code>infinite_loop</code> sẽ in ra thời gian sau mỗi 1s và không bao giờ dừng.</li><li>Còn với daemon thread như trên nó chỉ in ra 1 lần, khi thread chạy hàm main exit thì nó cũng… nghỉ luôn. Kết quả đây:</li></ul><pre><code class=\"bash language-bash\">1691860930.767461<br/></code></pre><h1 id=\"6semaphores\">6. Semaphores</h1><p>Với <code>lock</code>, ta khiến chương trình chờ 1 thread chạy xong trước khi sang thread khác, còn nếu muốn <strong>chờ nhiều (n) threads chạy đồng thời xong, trước khi chạy sang n threads kế tiếp</strong> thì sao? =&gt; Ta có Semaphores.<br/>Đoạn code dưới đây tạo ra 1 Semaphores cho phép 5 threads chạy đồng thời cùng lúc:</p><pre><code class=\"python language-python\">import time<br/>import threading<br/>sem = threading.Semaphore(5)<br/>def process_something(id: int):<br/>    sem.acquire()<br/>    print(f\"{id} -&amp;gt; Running!\")<br/>    time.sleep(5)<br/>    print(f\"{id} -&amp;gt; Finished!\")<br/>    sem.release()<br/>if __name__==\"__main__\":<br/>    for i in range(10):<br/>        time.sleep(0.5)<br/>        thread = threading.Thread(target=process_something, kwargs={\"id\": i+1})<br/>        thread.start()<br/></code></pre><p>Rất giống cấu trúc <code>acquire-release</code> của <code>lock</code> đúng không. Khi có bất kỳ thread nào chạy xong thì thread đang chờ sẽ được vào chạy luôn. Do đó, kết quả sẽ là:</p><pre><code class=\"bash language-bash\">1 -&amp;gt; Running!<br/>2 -&amp;gt; Running!<br/>3 -&amp;gt; Running!<br/>4 -&amp;gt; Running!<br/>5 -&amp;gt; Running!<br/>1 -&amp;gt; Finished!<br/>6 -&amp;gt; Running!<br/>2 -&amp;gt; Finished!<br/>7 -&amp;gt; Running!<br/>3 -&amp;gt; Finished!<br/>8 -&amp;gt; Running!<br/>4 -&amp;gt; Finished!<br/>9 -&amp;gt; Running!<br/>5 -&amp;gt; Finished!<br/>10 -&amp;gt; Running!<br/>6 -&amp;gt; Finished!<br/>7 -&amp;gt; Finished!<br/>8 -&amp;gt; Finished!<br/>9 -&amp;gt; Finished!<br/>10 -&amp;gt; Finished!<br/></code></pre><p>Lúc đầu, 5 threads được chạy đồng thời. Sau đó có 1 threads chạy xong (thread 1), lập tức thread tiếp theo được vào (thread 6),…</p><h1 id=\"7contextmanagercholocksemaphores\">7. Context manager cho Lock/Semaphores</h1><p>Để tránh quên <code>release</code> mỗi lần <code>acquire</code>, dẫn đến chương trình không thể thoát được, ta có thể sử dụng context manager với từ khóa <code>with</code>. Theo đó, việc <code>release</code> sẽ được tự động thực thi chừng nào đoạn code trong <code>with</code> được chạy xong.<br/>Ví dụ đoạn code Semaphores phía trên có thể được viết lại như sau:</p><pre><code class=\"python language-python\">import time<br/>import threading<br/>sem = threading.Semaphore(5)<br/>def process_something(id: int):<br/>    with sem:<br/>        print(f\"{id} -&amp;gt; Running!\")<br/>        time.sleep(5)<br/>        print(f\"{id} -&amp;gt; Finished!\")<br/>if __name__==\"__main__\":<br/>    for i in range(10):<br/>        time.sleep(0.5)<br/>        thread = threading.Thread(target=process_something, kwargs={\"id\": i+1})<br/>        thread.start()<br/></code></pre><p>Kết quả trả về sẽ không có gì thay đổi với việc dùng <code>acquire-release</code>.</p><h1 id=\"8racecondition\">8. Race condition</h1><p>Khi có nhiều thread cùng thay đổi vào 1 biến global, kết quả cuối cùng của biến đó sẽ không xác định được, đây chính là race condition. Xét VD sau:</p><pre><code class=\"python language-python\">import threading<br/>import time<br/>lock = threading.Lock()<br/>def edit(operation: str, amount: int, repeat: int):<br/>    global value<br/>    for _ in range(repeat):<br/>        temp: int = value<br/>        time.sleep(0)<br/>        if operation == \"add\":<br/>            temp += amount<br/>        elif operation == \"subtract\":<br/>            temp -= amount<br/>            time.sleep(0)<br/>            value = temp<br/>if __name__==\"__main__\":<br/>    value: int = 0<br/>    adder = threading.Thread(target=edit, args=(\"add\", 100, 1_000_000))<br/>    subtractor = threading.Thread(target=edit, args=(\"subtract\", 100, 1_000_000))<br/>    adder.start()<br/>    subtractor.start()<br/>    adder.join()<br/>    subtractor.join()<br/>    print(f\"{value = }\")<br/></code></pre><p>Kết quả mong muốn là 0 do ta cộng vào biến <code>value</code> 1,000,000 lần giá trị 100 sau đó lại trừ đi 1,000,000 lần giá trị 100.<br/>Tuy nhiên, khi chạy lại cho ra giá trị không bằng 0. Thậm chí, các lần chạy khác nhau cho ra giá trị không giống nhau.<br/>Điều này diễn ra là do 2 threads đang truy cập song song vào biến <code>value</code>, đoạn code <code>sleep</code> khiến có thể một phép cộng chưa thực thi xong, giá trị <code>value</code> chưa được update thì phép trừ đã được thực thi. Do đó, phép trừ khi này phải thực thi trên giá trị chưa cập nhật.<br/>Để giải quyết vấn đề này, chúng ta sẽ dùng <code>lock</code>:</p><pre><code class=\"python language-python\">import threading<br/>import time<br/>lock = threading.Lock()<br/>def edit(operation: str, amount: int, repeat: int):<br/>    global value<br/>    with lock:<br/>        for _ in range(repeat):<br/>            temp: int = value<br/>            time.sleep(0)<br/>            if operation == \"add\":<br/>                temp += amount<br/>            elif operation == \"subtract\":<br/>                temp -= amount<br/>            time.sleep(0)<br/>            value = temp<br/>if __name__==\"__main__\":<br/>    value: int = 0<br/>    adder = threading.Thread(target=edit, args=(\"add\", 100, 1_000_000))<br/>    subtractor = threading.Thread(target=edit, args=(\"subtract\", 100, 1_000_000))<br/>    adder.start()<br/>    subtractor.start()<br/>    adder.join()<br/>    subtractor.join()<br/>    print(f\"{value = }\")<br/></code></pre><p>Kết quả trả về sẽ luôn bằng 0 như kỳ vọng.<br/>Cảm ơn các bạn đã đọc hết bài này ☺️</p><p><strong>Tham khảo:</strong></p><ul><li>The Complete Guide To Mastering Python In 2023 - Udemy</li></ul>","title":"Những điều cần biết về Threading trong Python","tags":["Advance Python","Multi Threading","parallel programming","Multithread","async"],"created_at":1691868516000,"updated_at":1691983383000,"comments":[]}